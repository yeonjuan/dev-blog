
   <!doctype html>
    <html lang="ko">
      <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width" />
        <title>사용자가 페이지를 떠날 때 안정적으로 HTTP 요청 보내기 (번역) | DevBlog</title>
        <link href="/dev-blog/favicon.ico" rel="shortcut icon">
        <meta name="description" content="이 글에서는 사용자가 웹 페이지를 떠날 때 로깅을 위한 요청을 안정적으로 전송하는 방법에 대해 소개합니다. 웹 페이지를 종료하거나 다른 페이지로 이동할 때 HTTP 요청이 취소되는 현상과 이를 해결할 수 있는 몇 가지 방법을 소개합니다.">
        <meta property="og:image" content="/dev-blog/posts/Browser/assets/send-an-http-request-on-page-exit.webp" /> 
        <meta property="og:type" content="blog" />
        <meta property="og:title" content="사용자가 페이지를 떠날 때 안정적으로 HTTP 요청 보내기 (번역) | DevBlog" /> 
        <meta property="og:description" content="이 글에서는 사용자가 웹 페이지를 떠날 때 로깅을 위한 요청을 안정적으로 전송하는 방법에 대해 소개합니다. 웹 페이지를 종료하거나 다른 페이지로 이동할 때 HTTP 요청이 취소되는 현상과 이를 해결할 수 있는 몇 가지 방법을 소개합니다." /> 
        <link href="/dev-blog/output.css" type="text/css" rel="stylesheet" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
          href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&display=swap"
          rel="stylesheet"
        />
        <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "BlogPosting",
          "headline": "사용자가 페이지를 떠날 때 안정적으로 HTTP 요청 보내기 (번역) | DevBlog",
          "image": [
            "https://yeonjuan.github.io//dev-blog/posts/Browser/assets/send-an-http-request-on-page-exit.webp"
          ],
            
              "datePublished": "2022-11-21T00:00:00+09:00",
              "dateModified": "2022-11-21T00:00:00+09:00",
              
          "author": [{
              "@type": "Person",
              "name": "YeonJuAn",
              "url": "https://github.com/yeonjuan"
            }]
        }
        </script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZBZX7LMVNE"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-ZBZX7LMVNE');
        </script>
        
      <link href="/dev-blog/css/github.min.css" type="text/css" rel="stylesheet" />
    
    
      </head>
      <body>
        <div class="relative">
            
  <style>
        .hamburger {
            cursor: pointer;
            justify-content: space-between;
            flex-direction: column;
        }
        .hamburger > div {
            height: 2px;
            transition: 0.2s ease-out;
            z-index: 999;
        }
        .menuInput:checked ~ .hamburger > div:nth-child(1) {
            transform: translateY(6.5px) rotate(45deg);
        }
        .menuInput:checked ~ .hamburger > div:nth-child(2) {
            opacity: 0;
        }
        .menuInput:checked ~ .hamburger > div:nth-child(3) {
            transform: translateY(-6.5px) rotate(-45deg);
        }
    </style>
  <div id="overlay" class="backdrop-blur-sm bg-black/20 dark:bg-slate-900/80 fixed h-full inset-0 hidden"></div>
  <header class="bg-zinc-800 text-white h-12 fixed flex justify-between items-center w-full px-4">
    <a
      class="w-10 flex items-center justify-center"
      href="https://github.com/yeonjuan/dev-blog"
      target="_blank"
      rel="noopener noreferrer"
    >
      <img
        src="/dev-blog/assets/ic-github.svg"
        alt="go to github"
        width="20"
      >
    </a>
    <span>
      <a href="/dev-blog/">
        DEV BLOG
      </a>
    </span>
    <div class="w-10">
      <input
        id="menu"
        type="checkbox"
        class="menuInput peer sr-only hidden"
        aria-hidden="true"
      >
      <label
        for="menu"
        aria-label="menu button"
        class="hamburger flex flex-col justify-between ml-auto h-[21px] w-[21px] px-[1px] py-[3px] [&>div]:h-[2px] [&>div]:w-[18px] [&>div]:bg-white hover:cursor-pointer"
      >
        <div></div>
        <div></div>
        <div></div>
      </label>
      <nav class="fixed text-black transition-[max-height] duration-200 overflow-hidden max-h-0 top-12 left-[0px] peer-checked:max-h-[200px] bg-white w-full border-b border-black">
        <ul class="p-4">
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/">HOME</a>
          </li>
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/posts/JavaScript">JavaScript</a>
          </li>
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/posts/Review">Review</a>
          </li>
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/posts/Browser">Browser</a>
          </li>
        </ul>
      </nav>
    </div>
  </header>

          <main class="py-2 px-4 pt-10 max-w-3xl m-auto pb-20">
          
            <aside class="mt-14">
              <a href="/dev-blog/" class="hover:underline">Home</a> &gt; <a href="/dev-blog/posts/Browser" class="hover:underline">JavaScript</a> &gt; <a href="/dev-blog/posts/Browser/send-an-http-request-on-page-exit" class="hover:underline">사용자가 페이지를 떠날 때 안정적으로 HTTP 요청 보내기 (번역)</a>
            </aside>
          
            
    <h1 id="-http" class="text-2xl my-8 font-bold">
      사용자가 페이지를 떠날 때 안정적으로 HTTP 요청 보내기
    </h1><blockquote class="border-l-2 border-black pl-2 my-4"><p class="my-1 text-sm leading-7 mb-6">이 글은 <a href="https://css-tricks.com/author/alexmacarthur/" class="text-orange-500">Alex AcArthur</a>가 작성한 <a href="https://css-tricks.com/send-an-http-request-on-page-exit/" class="text-orange-500">Reliably Send an HTTP Request as a User Leaves a Page</a>를 번역한 글입니다 (<a href="https://css-tricks.com/translate-an-article/" class="text-orange-500">CSS-Tricks 번역 정책 참고</a>).</p></blockquote><p class="my-1 text-sm leading-7 mb-6">사용자가 다른 페이지로 이동하거나 양식을 제출하는 등의 행동을 할 때, 로깅할 데이터가 포함된 HTTP 요청을 전송해야 하는 경우가 여러 번 있었습니다.
링크를 클릭하면 일부 정보를 외부 서비스로 전송하는 예시를 생각해 보세요: </p><pre><code class="my-4 hljs text-xs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/some-other-page&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;link&quot;</span>&gt;</span>Go to Page<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;link&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/log&quot;</span>, {
    <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,
    <span class="hljs-attr">headers</span>: {
      <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>
    }, 
    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
      <span class="hljs-attr">some</span>: <span class="hljs-string">&quot;data&quot;</span>
    })
  });
});
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p class="my-1 text-sm leading-7 mb-6">여기에 크게 복잡한 건 없습니다.
보통 그렇듯이 (<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">e.preventDefault()</code>를 사용하지 않았습니다.) 링크는 정상적으로 동작하도록 했지만, 링크가 동작하기 전, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">click</code> 시에 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">POST</code> 요청이 발생합니다.
어떤 종류의 응답도 기다릴 필요가 없습니다.
어떤 결과를 받던지 <strong>단지 전송만</strong> 하기를 원합니다.</p><p class="my-1 text-sm leading-7 mb-6">언뜻 보면, 해당 요청의 전송이 동기화된 것처럼 보이고, 그 후 다른 서버가 요청을 성공적으로 처리하는 동안 페이지를 계속 탐색할 것처럼 보입니다.
하지만 밝혀진 바로, 항상 그런 것은 아닙니다.</p>
    <h2 id="-http" class="text-xl my-4 font-semibold">
      브라우저는 열린 HTTP 요청의 보존을 보장하지 않습니다.
    </h2><p class="my-1 text-sm leading-7 mb-6">무언가 브라우저의 페이지를 종료시킬 때, 진행 중인 HTTP 요청이 성공적으로 처리된다는 보장은 없습니다(<a href="https://developer.chrome.com/blog/page-lifecycle-api/" class="text-orange-500">페이지 생명 주기의 &quot;terminated&quot; 및 다른 상태</a> 참고).
이런 종류의 요청의 신뢰성은 네트워크 연결, 애플리케이션 성능 및 외부 서비스 자체 설정과 같은 몇 가지 요소에 따라 달라질 수 있습니다.</p><p class="my-1 text-sm leading-7 mb-6">따라서, 이러한 시점에 데이터를 전송하는 것은 결코 신뢰할 수 없으며, 이런 로그에 의존해 데이터에 민감한 비즈니스 의사결정을 내리게 되면 잠재적으로 큰 문제가 발생할 수 있습니다.</p><p class="my-1 text-sm leading-7 mb-6">비신뢰성에 대한 설명을 위해 위 코드를 포함한 페이지가 있는 작은 Express 애플리케이션을 만들었습니다.
링크가 클릭되었을 때 브라우저는 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">/other</code>로 이동합니다, 하지만 그전에 POST 요청이 발생합니다.</p><p class="my-1 text-sm leading-7 mb-6">모든 과정 동안, 저는 브라우저의 네트워크 탭을 열어두고 연결 속도를 &quot;Slow 3g&quot;로 사용했습니다.
페이지를 로드하고 로그를 지웠습니다, 아무런 문제도 없는 것처럼 보입니다:</p><p class="my-1 text-sm leading-7 mb-6"><img class="my-4 border-gray-300 border rounded-sm p-1" alt="" src="./assets//initial-load-1.png"></p><p class="my-1 text-sm leading-7 mb-6">하지만 링크를 클릭하면 일이 꼬입니다.
페이지 이동이 발생할 때, 요청이 취소됩니다.</p><p class="my-1 text-sm leading-7 mb-6"><img class="my-4 border-gray-300 border rounded-sm p-1" alt="" src="./assets/request-failed-1.webp"></p><p class="my-1 text-sm leading-7 mb-6">따라서 외부 서비스가 실제로 요청을 처리할 수 있었다는 확신을 할 수 없습니다.
이 동작을 확인하기 위해 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">window.location</code>을 이용해 프로그래밍적으로 페이지를 이동해도 같은 문제가 발생합니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;link&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
+ e.<span class="hljs-title function_">preventDefault</span>();

  <span class="hljs-comment">// 요청이 대기열에 들어갔지만, 페이지 이동이 일어나면서 취소됩니다.</span>
  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/log&quot;</span>, {
    <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,
    <span class="hljs-attr">headers</span>: {
      <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>
    }, 
    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
      <span class="hljs-attr">some</span>: <span class="hljs-string">&#x27;data&#x27;</span>
    }),
  });

+ <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">href</span>;
});</code></pre><p class="my-1 text-sm leading-7 mb-6">언제 어떻게 페이지 이동이 발생하고 활성 페이지가 종료되는 지와 관계없이, 이런 완료되지 않은 요청은 취소될 위험이 있습니다.</p>
    <h2 id="" class="text-xl my-4 font-semibold">
      근데 왜 취소될까요?
    </h2><p class="my-1 text-sm leading-7 mb-6">근본적인 원인은, 기본적으로 XHR 요청(<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">fetch</code> 혹은 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">XMLHttpRequest</code>에 의한)은 비동기적이고 블로킹이 없다는 것입니다.
요청이 대기열에 들어가자마자, 요청의 실제 <em>작업</em>은 백그라운드에서 브라우저 레벨의 API로 전달됩니다.</p><p class="my-1 text-sm leading-7 mb-6">우리는 요청이 메인 스레드를 독차지하는 것을 원하지 않기 때문에 이는 성능 면에서 좋습니다.
하지만 이는 페이지가 &quot;terminated&quot; 상태가 될 때 요청이 버려질 위험이 있다는 것을 뜻하며, 그 어떤 백그라운드 작업도 완료된다는 보장이 없습니다.
여기 <a href="https://developer.chrome.com/blog/page-lifecycle-api/#states" class="text-orange-500">Google 이 라이프 사이클 상태</a>에 대해 어떻게 요약했는지 보겠습니다:</p><blockquote class="border-l-2 border-black pl-2 my-4"><p class="my-1 text-sm leading-7 mb-6">브라우저 메모리에서 내려가고 지워지기 시작하면 페이지는 terminated 상태가 됩니다.
이 상태에서는 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#queue-a-task" class="text-orange-500">새로운 작업</a>이 시작되지 않으며, 진행 중인 작업이 너무 오래 실행될 경우 중지될 수 있습니다.</p></blockquote><p class="my-1 text-sm leading-7 mb-6">간단히 말해서, 브라우저는 페이지가 삭제될 때, 페이지에 의해 대기 중인 백그라운드 프로세스를 계속 처리할 필요가 없다는 가정 하에 설계되었습니다.</p>
    <h2 id="" class="text-xl my-4 font-semibold">
      그래서, 우리가 선택할 수 있는 건 무엇일까요?
    </h2><p class="my-1 text-sm leading-7 mb-6">아마 이 문제를 피하기 위한 가장 명확한 접근 방법은 요청이 응답을 반환할 때까지 사용자 작업을 지연시키는 것입니다.
예전에는, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">XMLHttpRequest</code>에서 지원하는 <a href="https://xhr.spec.whatwg.org/#synchronous-flag" class="text-orange-500">synchronous 플래그</a>를 사용하는 잘못된 방식으로 하곤 했습니다.
하지만 이를 사용하면 메인 스레드를 완전히 차단시키고, 여러 성능 문제가 발생합니다 - 저는 이런 문제에 대한 <a href="https://macarthur.me/posts/use-web-workers-for-your-event-listeners" class="text-orange-500">글</a>을 작성했었습니다 - 그래서 이 방식은 고려할 필요도 없습니다.
사실, 이 기능은 플랫폼에서 제거되고 있습니다 (<a href="https://developer.chrome.com/blog/chrome-80-deps-rems/" class="text-orange-500">Chrome v80+에서는 이미 제거되었습니다.</a>)</p><p class="my-1 text-sm leading-7 mb-6">대신, 이런 접근 방식을 사용할 경우 응답이 반환되어 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Promise</code> 가 resolve 될 때까지 기다리는 것이 좋습니다.
다시 돌아온 후에는 안전하게 동작을 수행할 수 있습니다.
앞선 예제를 사용하면, 아래처럼 할 수 있습니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;link&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-title function_">async</span> (e) =&gt; {
  e.<span class="hljs-title function_">preventDefault</span>();

  <span class="hljs-comment">// 응답이 돌아오기를 기다리고...</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/log&quot;</span>, {
    <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,
    <span class="hljs-attr">headers</span>: {
      <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>
    }, 
    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
      <span class="hljs-attr">some</span>: <span class="hljs-string">&#x27;data&#x27;</span>
    }),
  });

  <span class="hljs-comment">// ...나서 페이지를 이동한다.</span>
   <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">href</span>;
});</code></pre><p class="my-1 text-sm leading-7 mb-6">이러면 작업을 완료할 수 있지만, 몇 가지 사소하지 않은 단점이 있습니다.</p><p class="my-1 text-sm leading-7 mb-6"><strong>첫째, 원하는 동작이 발생하지 않도록 지연시킴으로써 사용자 경험을 손상시킵니다.</strong>
분석 데이터를 수집하는 것은 확실히 비즈니스(그리고 잠재적 사용자들)에게 이익이 되지만, <em>현재</em> 사용자가 그 이익을 위해 비용을 지불하도록 하는 것은 이상적이지 않습니다.
말할 것도 없이, 외부 종속성에 의해, 그 서비스 자체가 가진 어떠한 지연이나 성능 문제가 사용자에게 보여지게 됩니다.
분석 서비스에서 타임아웃이 발생해서 고객이 중요한 작업을 하지 못하면 모든 사람이 손해를 보게 됩니다.</p><p class="my-1 text-sm leading-7 mb-6"><strong>둘째, 몇몇 종료 동작은 프로그래밍 방식으로 지연시킬 수 없기 때문에 이런 접근은 앞에서 들었던 것처럼 신뢰할 수 없습니다.</strong>
예를 들어 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">e.preventDefault()</code>는 브라우저 탭을 닫는 것을 지연시킬 때는 효과가 없습니다.
그래서 기껏해야, <em>일부</em> 사용자 작업에 대한 데이터 수집은 커버할 수 있지만 종합적으로 신뢰할 수 있을 정도는 아닙니다. </p>
    <h2 id="" class="text-xl my-4 font-semibold">
      브라우저에 미처리 요청을 보존하도록 지시하기
    </h2><p class="my-1 text-sm leading-7 mb-6">다행히, 미처리 HTTP 요청을 <em>보존</em>할 수 있는 옵션이 있고, 이는 대부분의 브라우저에 내장되어 있으며 사용자 경험을 손상시키지 않습니다.</p>Fetch 의 `keepalive` 플래그 사용하기<p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">fetch()</code>를 사용할 때 <a href="https://fetch.spec.whatwg.org/#request-keepalive-flag" class="text-orange-500">keepalive</a> 플래그가 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">true</code>로 설정되어 있으면, 해당 요청을 시작한 페이지가 종료되더라도 해당 요청이 열린 상태로 유지됩니다. 
처음 예제를 사용하면 다음과 같이 구현할 수 있습니다.</p><pre><code class="my-4 hljs text-xs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/some-other-page&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;link&quot;</span>&gt;</span>Go to Page<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;link&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/log&quot;</span>, {
      <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>,
      <span class="hljs-attr">headers</span>: {
        <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>
      }, 
      <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
        <span class="hljs-attr">some</span>: <span class="hljs-string">&quot;data&quot;</span>
      }), 
      <span class="hljs-attr">keepalive</span>: <span class="hljs-literal">true</span>
    });
  });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p class="my-1 text-sm leading-7 mb-6">해당 링크를 클릭하고 페이지 이동이 발생해도, 요청 취소가 발생하지 않습니다:</p><p class="my-1 text-sm leading-7 mb-6"><img class="my-4 border-gray-300 border rounded-sm p-1" alt="" src="./assets/request-priorities.webp"></p><p class="my-1 text-sm leading-7 mb-6">대신, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">(unknown)</code> 상태가 남게 되는데, 단순히 활성 페이지가 어떤 종료의 응답도 기다리지 않기 때문입니다.</p><p class="my-1 text-sm leading-7 mb-6">특히, 일반적으로 사용되는 브라우저 API의 일부인 경우 이와 같이 한 줄이면 쉽게 해결할 수 있습니다.
그러나 더 단순한 인터페이스를 가진 더 집중적인 옵션을 찾고 있다면, 브라우저 지원을 받는 다른 방법도 있습니다.</p>`Navigator.sendBeacon()` 사용하기<p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Navigator.sendBeacon()</code> 함수는 단방향 요청을 전송하기 위해 특별히 고안되었습니다 (<a href="https://w3c.github.io/beacon/#sec-processing-model" class="text-orange-500">beacons</a>).
기본 구현은 다음과 같습니다. 직렬화된 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">JSON</code> 과 “text/plain” <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Content-Type</code> 을 포함한 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">POST</code> 요청을 전송합니다:</p><pre><code class="my-4 hljs text-xs language-js">navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&#x27;/log&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
  <span class="hljs-attr">some</span>: <span class="hljs-string">&quot;data&quot;</span>
}));</code></pre><p class="my-1 text-sm leading-7 mb-6">하지만, 이 API는 커스텀 헤더를 보내도록 허용하지 않습니다.
그래서, 데이터를 “application/json” 로 전송하려면 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Blob</code>을 사용해 약간 수정해서 사용해야 합니다:  </p><pre><code class="my-4 hljs text-xs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/some-other-page&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;link&quot;</span>&gt;</span>Go to Page<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;link&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">some</span>: <span class="hljs-string">&quot;data&quot;</span> })], { <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;application/json; charset=UTF-8&#x27;</span> });
    navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&#x27;/log&#x27;</span>, blob);
  });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p class="my-1 text-sm leading-7 mb-6">결국, 동일한 결과를 얻을 수 있습니다 - 페이지 이동 후에도 요청을 완료할 수 있습니다.
하지만 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">fetch()</code> 보다 나은 점이 있습니다: 비콘은 낮은 우선순위로 전송됩니다.</p><p class="my-1 text-sm leading-7 mb-6">설명을 위해, 여기 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">keepalive</code> 가 있는 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">fetch()</code>와 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">sendBeacon()</code>이 동시에 사용될 때 네트워크 탭에 표시되는 것입니다: </p><p class="my-1 text-sm leading-7 mb-6"><img class="my-4 border-gray-300 border rounded-sm p-1" alt="" src="./assets/request-priorities.webp"></p><p class="my-1 text-sm leading-7 mb-6">기본적으로, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">fetch()</code>는 “High” 우선 순위를 받는 반면, 비콘은(위에서 “ping” 유형으로 표시됨)은 “Lowest” 우선 순위를 가집니다.
페이지 기능에 중요하지 않은 요청의 경우 이 방법은 좋습니다.
<a href="https://www.w3.org/TR/beacon/" class="text-orange-500">Beacon 스펙</a>에서 발췌한 내용입니다:</p><blockquote class="border-l-2 border-black pl-2 my-4"><p class="my-1 text-sm leading-7 mb-6">이 스펙은 다음 인터페이스를 정의합니다 […] 시간적으로 중요한 다른 작업과 리소스 경합을 최소화하면서 요청이 계속 처리되고 대상으로 전달되도록 보장합니다.</p></blockquote><p class="my-1 text-sm leading-7 mb-6">다른 말로하면, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">sendBeacon()</code> 은 그 요청이 애플리케이션에 중요한 것들과 사용자 경험에 관여하지 않도록 합니다.</p>
    <h2 id="-ping" class="text-xl my-4 font-semibold">
      `ping` 속성에 대한 훌륭한 언급
    </h2><p class="my-1 text-sm leading-7 mb-6">점점 더 많은 브라우저들이 <a href="https://css-tricks.com/the-ping-attribute-on-anchor-links/" class="text-orange-500">ping 속성</a>을 지원한다는 것을 언급할 가치가 있습니다.
링크에 사용되면 이는 작은 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">POST</code> 요청을 전송합니다.</p><pre><code class="my-4 hljs text-xs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://localhost:3000/other&quot;</span> <span class="hljs-attr">ping</span>=<span class="hljs-string">&quot;http://localhost:3000/log&quot;</span>&gt;</span>
  Go to Other Page
<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p class="my-1 text-sm leading-7 mb-6">이 요청 헤더에는 링크가 클릭된 페이지(<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">ping-from</code>)와 해당 링크의 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">href</code> 값(<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">ping-to</code>)이 포함됩니다: </p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-attr">headers</span>: {
  <span class="hljs-string">&#x27;ping-from&#x27;</span>: <span class="hljs-string">&#x27;http://localhost:3000/&#x27;</span>,
  <span class="hljs-string">&#x27;ping-to&#x27;</span>: <span class="hljs-string">&#x27;http://localhost:3000/other&#x27;</span>
  <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/ping&#x27;</span>
  <span class="hljs-comment">// ...다른 헤더들</span>
},</code></pre><p class="my-1 text-sm leading-7 mb-6">이는 비콘 전송과 기술적으로 유사하지만, 주목할 만한 제한사항이 있습니다.</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><strong>링크에서만 사용할 수 있도록 엄격하게 제한되므로</strong>, 버튼클릭이나 양식 제출과 같은 다른 상호작용과 관련된 데이터를 추적해야 하는 경우 사용할 수 없습니다.</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><strong>브라우저 지원이 나쁘지는 않지만, <a href="https://caniuse.com/ping" class="text-orange-500">아주 좋지는 않습니다</a></strong>. 글을 작성하는 현재, Firefox는 기본적으로 이를 사용하지 않도록 설정되어 있습니다.</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><strong>요청과 함께 커스텀 데이터를 보낼수 없습니다.</strong> 언급한 바와 같이 몇가지 ping-* 헤더와 몇가지 다른 헤더를 같이 얻을 수 있습니다.</p></li></ul><p class="my-1 text-sm leading-7 mb-6">모든 것을 고려해 볼 때, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">ping</code> 은 간단한 요청으로 충분하고 커스텀 JavaScript 를 작성하지 않으려는 경우 좋은 방법입니다.
하지만 더 중요한 것을 보내야한다면, 가장 좋은 방법은 아닐 수 있습니다.</p>
    <h2 id="" class="text-xl my-4 font-semibold">
      그래서 어떤것을 사용해야 할까요?
    </h2><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">keepalive</code>와 함께 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">fetch</code>를 사용하거나 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">sendBeacon()</code>을 사용하여 마지막 요청을 전송하는 것에는 분명한 트레이드오프가 있습니다.
다양한 상황에 가장 적합한 항목을 식별하기 위해 고려해야 할 몇 가지 사항은 다음과 같습니다:</p>아래와 같은 경우에는 `fetch()` + `keepalive` 를 사용하는 것이 좋습니다.<ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">요청과 함께 커스텀 헤더를 쉽게 전달해야 합니다.</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">서비스에 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">POST</code> 가 아닌 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">GET</code> 요청을 하려고 합니다.</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">예전 브라우저(IE 같은)를 지원하고 있으며 이미 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">fetch</code> 폴리필이 로드되어 있습니다.</p></li></ul>하지만 아래의 경우에는 `sendBeacon()`이 더 좋은 선택일 수 있습니다.<ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">커스텀이 많이 필요하지 않은 간단한 서비스 요청을 하고 있습니다.</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">깔끔하고 우아한 API 를 선호합니다.</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">요청이 애플리케이션에서 발송되는 다른 높은 우선순위의 요청과 경쟁하지 않도록 보장하려 합니다</p></li></ul>
    <h2 id="" class="text-xl my-4 font-semibold">
      제 실수를 반복하지 마세요
    </h2><p class="my-1 text-sm leading-7 mb-6">페이지가 종료될 때 브라우저가 처리 중인 요청을 다루는 방식에 대해서 자세히 알아보기로 한 이유가 있습니다.
얼마 전, 우리 팀은 양식을 제출할 때 요청을 실행하기 시작한 후 갑자기 특정 유형의 분석 로그 빈도가 변하는 것을 보았습니다.
이 변화는 갑작스러웠고 중요했습니다 - 과거에 보았던 것보다 약 ~30% 감소했습니다.</p><p class="my-1 text-sm leading-7 mb-6">이 문제가 발생한 이유와 이를 피할 수 있는 도구를 파헤쳐 곤경을 면할 수 있었습니다.
그래서, 저는 이런 도전들의 뉘앙스를 이해하는 것이 누군가 우리가 마주친 고통의 일부를 피하는데 도움이 되기를 바랍니다.
Happy logging!</p>
          </main>
        </div>
        <script src="/dev-blog/scripts/header.js"></script>
      </body>
    </html>
    