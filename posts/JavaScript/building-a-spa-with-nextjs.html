
   <!doctype html>
    <html lang="ko">
      <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width" />
        <title>Next.js 와 React Router로 싱글 페이지 애플리케이션 만들기 | DevBlog</title>
        <link href="/dev-blog/favicon.ico" rel="shortcut icon">
        <meta name="description" content="이 글에서는 Next.js 와 react-router-dom 을 이용해 SPA를 구성하는 방법에 대해 소개합니다. 일반적으로 Next.js를 사용하는 경우 내장된 라우터만 사용하는데요. 최근 저는 서비스의 특별한 이유로 react-router-dom 과 내장된 라우터를 같이 사용해야만 했고, 프로젝트를 구성하는데 이 글에서 도움을 받았습니다. 저와 같은 문제를 겪으시는 분들에게 도움이 되었으면 좋겠습니다.">
        <link href="/dev-blog/output.css" type="text/css" rel="stylesheet" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
          href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&display=swap"
          rel="stylesheet"
        />
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZBZX7LMVNE"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-ZBZX7LMVNE');
        </script>
        
      <link href="/dev-blog/css/github.min.css" type="text/css" rel="stylesheet" />
    
    
      </head>
      <body>
        <div class="relative">
            
  <style>
        .hamburger {
            cursor: pointer;
            justify-content: space-between;
            flex-direction: column;
        }
        .hamburger > div {
            height: 2px;
            transition: 0.2s ease-out;
            z-index: 999;
        }
        .menuInput:checked ~ .hamburger > div:nth-child(1) {
            transform: translateY(6.5px) rotate(45deg);
        }
        .menuInput:checked ~ .hamburger > div:nth-child(2) {
            opacity: 0;
        }
        .menuInput:checked ~ .hamburger > div:nth-child(3) {
            transform: translateY(-6.5px) rotate(-45deg);
        }
    </style>
  <div id="overlay" class="backdrop-blur-sm bg-black/20 dark:bg-slate-900/80 fixed h-full inset-0 hidden"></div>
  <header class="bg-zinc-800 text-white h-12 fixed flex justify-between items-center w-full px-4">
    <a
      class="w-10 flex items-center justify-center"
      href="https://github.com/yeonjuan/dev-blog"
      target="_blank"
      rel="noopener noreferrer"
    >
      <img
        src="/dev-blog/assets/ic-github.svg"
        alt="go to github"
        width="20"
      >
    </a>
    <span>
      <a href="/dev-blog/">
        DEV BLOG
      </a>
    </span>
    <div class="w-10">
      <input
        id="menu"
        type="checkbox"
        class="menuInput peer sr-only hidden"
        aria-hidden="true"
      >
      <label
        for="menu"
        aria-label="menu button"
        class="hamburger flex flex-col justify-between ml-auto h-[21px] w-[21px] px-[1px] py-[3px] [&>div]:h-[2px] [&>div]:w-[18px] [&>div]:bg-white hover:cursor-pointer"
      >
        <div></div>
        <div></div>
        <div></div>
      </label>
      <nav class="fixed text-black transition-[max-height] duration-200 overflow-hidden max-h-0 top-12 left-[0px] peer-checked:max-h-[200px] bg-white w-full border-b border-black">
        <ul class="p-4">
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/">HOME</a>
          </li>
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/posts/JavaScript">JavaScript</a>
          </li>
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/posts/Review">Review</a>
          </li>
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/posts/Browser">Browser</a>
          </li>
        </ul>
      </nav>
    </div>
  </header>

          <main class="py-2 px-4 pt-10 max-w-3xl m-auto pb-20">
          
            <aside class="mt-14">
              <a href="/dev-blog/" class="hover:underline">Home</a> &gt; <a href="/dev-blog/posts/JavaScript" class="hover:underline">JavaScript</a> &gt; <a href="/dev-blog/posts/JavaScript/building-a-spa-with-nextjs" class="hover:underline">Next.js 와 React Router로 싱글 페이지 애플리케이션 만들기</a>
            </aside>
          
            
    <h1 id="next-js-react-router" class="text-2xl my-8 font-bold">
      Next.js 와 React Router로 싱글 페이지 애플리케이션 만들기
    </h1><blockquote class="border-l-2 border-black pl-2 my-4"><p class="my-1 text-sm leading-7 mb-6">원문: <a href="https://colinhacks.com/essays/building-a-spa-with-nextjs" class="text-orange-500">https://colinhacks.com/essays/building-a-spa-with-nextjs</a></p></blockquote><p class="my-1 text-sm leading-7 mb-6">최근 Next.js 를 이용하여 싱글 페이지 애플리케이션(SPA)를 구현하기 시작했습니다.</p><p class="my-1 text-sm leading-7 mb-6">명확하게 말씀드리면, 저는 &quot;SPA&quot;라는 용어를 매우 특정한 방식으로 사용하고 있습니다.
모든 데이터 패치, 렌더링, 라우팅을 클라이언트 사이드에서 처리하는 애플리케이션인 &quot;엣날 방식&quot;의 SPA 모델을 의미합니다.</p><p class="my-1 text-sm leading-7 mb-6">그런데 Next.js에서는 이 작업이 쉽지 않습니다.</p>
    <h2 id="-next-js" class="text-xl my-4 font-semibold">
      왜 Next.js의 라우팅을 사용하지 않나요?
    </h2><p class="my-1 text-sm leading-7 mb-6">Next.js는 React Router 만큼 유연하지 않습니다!
React Router를 사용하면 유연한 방식으로 라우터를 계층적으로 중첩할 수 있습니다.
&quot;부모&quot; 라우터는 모든 &quot;자식&quot; 라우터와 데이터를 쉽게 공유할 수 있습니다.
이는 최상위 라우터와(예: <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">/about</code> 과 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">/team</code>) 중첩된 라우터(예: <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">/settings/team</code> 과 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">/settings/user</code>)에서도 가능합니다.</p><p class="my-1 text-sm leading-7 mb-6">이는 Next.js에 내장된 라우터로는 불가능합니다! 대신 <em>모든</em> 공유 상태 및 레이아웃을 직접 만든 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">_app.tsx</code> 컴포넌트에서 초기화해야 합니다.
이는 하나의 최상위 React Router 만으로 앱을 구축하는 것과 같습니다.
Next.js가 &quot;중첩된 라우트&quot;를 정의할 수 있게 해준다 해도 이는 사실입니다.
실제로 Next.js는 모든 라우트를 &quot;평탄&quot;하게 만듭니다.</p><p class="my-1 text-sm leading-7 mb-6">Next에서 이를 구현하기 위해 복잡하고 해키(hacky)한 방법들이 있습니다. Adam Wathan이 <a href="https://adamwathan.me/2019/10/17/persistent-layout-patterns-in-nextjs/" class="text-orange-500">여기서</a> 설명한 몇 가지 방법들이 그 예시입니다.
Next.js의 라우팅 시스템을 사용하기로 결정한 경우 이런 접근 방식을 검토해야 합니다.</p>
    <h2 id="-next-js" class="text-xl my-4 font-semibold">
      왜 Next.js를 사용하나요?
    </h2><p class="my-1 text-sm leading-7 mb-6">왜냐하면 멋지기 때문입니다!
동적 import 기능으로 번들을 분할할 수 있으므로 대규모 SPA와 관련된 가장 큰 성능 문제 중 하나를 해결할 수 있습니다.
또한 Vercel에 쉽게 배포할 수 있으며, 별도의 클라이언트 및 서버 코드 베이스를 유지하는 대신 API 라우트를 사용해 API를 구축할 수 있습니다.
게다가 멋지고 새로운 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">&lt;Image&gt;</code> 컴포넌트도 제공합니다.</p><p class="my-1 text-sm leading-7 mb-6">하지만 Next.js의 가장 매력적인 기능은 별도의 설정 없이 클라이언트와 서버 간에 코드를 공유할 수 있다는 점입니다.</p><p class="my-1 text-sm leading-7 mb-6">클라이언트와 서버 간에 코드와 타이핑을 공유할 수 있다는 것은 대단한 장점입니다.
개발자 경험이 Lerna 보다 10배, Yarn 워크스페이스 보다는 100배는 더 좋습니다.(절 믿으세요)
이 기능은 종단간 안전한 타입의 데이터 레이어를 구축할 수 있는 새로운 라이브러리 <a href="https://github.com/trpc/trpc" class="text-orange-500">github.com/colinhacks/trpc</a>의 기반이 되는 기능입니다.
더 좋은 점은 API를 완전히 추상화하여 클라이언트에서 직접 서버 측 함수를 호출할 수 있다는 점입니다.
전 편애하고 있긴 하지만 정말 멋진 기능입니다.
자세한 내용은 <a href="https://github.com/trpc/trpc" class="text-orange-500">github.com/colinhacks/trpc</a>에서 확인해 보세요!✨</p>
    <h2 id="" class="text-xl my-4 font-semibold">
      구현
    </h2><p class="my-1 text-sm leading-7 mb-6">상호작용이 많은 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">대시보드 스타일</code> SaaS 개발에서 여전히 지배적인 패러다임은 SPA입니다.
안타깝게도 Next.js는 라우팅이라는 한 가지 근본적인 이유 때문에 SPA 패러다임과 (거의) 호환되지 않습니다.</p><p class="my-1 text-sm leading-7 mb-6">일반적인 SPA는 클라이언트 측 라우팅에 의존하는 반면, Next.js는 자체 페이지 기반 라우팅 시스템이 내장되어 있습니다. 일반적으로 <a href="https://reactrouter.com/en/main" class="text-orange-500">react-router</a>와 같은 라이브러리를 사용합니다.</p><p class="my-1 text-sm leading-7 mb-6">아래에서는 Next 앱에서 React Router를 사용하려고 할 때 발생한 모든 오류와 그 해결 방법을 설명하겠습니다.
데모를 위해 아래의 간단한 라우터를 사용하겠습니다.
이 라우터는 <a href="https://reactrouter.com/en/6.11.2/web/guides/quick-start#quick-start-1st-example-basic-routing" class="text-orange-500">react-router 문서</a>의 &quot;Basic Routing&quot; 예제를 단순화한 버전입니다.</p><pre><code class="my-4 hljs text-xs language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">BrowserRouter</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Router</span>, <span class="hljs-title class_">Routes</span>, <span class="hljs-title class_">Route</span>, <span class="hljs-title class_">Link</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/about&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">h1</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>} /&gt;
          <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">h1</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>} /&gt;
        <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span>
  );
}</code></pre>
    <h2 id="-browser-history-needs-a-dom" class="text-xl my-4 font-semibold">
      `Browser history needs a DOM`
    </h2><p class="my-1 text-sm leading-7 mb-6">먼저 새로운 Next.js 앱을 만들고, React Router를 설치한 다음 (<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">npm install react-router-dom</code>), 위 라우터 코드를 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">pages/index.tsx</code>에 붙여 넣어 보겠습니다.
그리고 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">next dev</code>를 실행하면 즉시 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Invariant failed: Browser history needs a DOM </code> 에러가 발생합니다.</p><p class="my-1 text-sm leading-7 mb-6"><img class="my-4 border-gray-300 border rounded-sm p-1" src="./assets/nextjs_no_dom.png"></p><p class="my-1 text-sm leading-7 mb-6">이는 Next.js가 개발 모드에서 개발 서버에 페이지를 미리 렌더링하려고 시도하기 때문에 발생합니다.
반면 React Router는 브라우저에서 제공하는 전역 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">window</code> 객체에 접근이 필요합니다.
서버 환경에서는 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">window</code>를 사용할 수 없기 때문에 React Router가 작동을 멈춥니다.</p><p class="my-1 text-sm leading-7 mb-6">이 문제를 해결하려면 (두둥) <a href="https://nextjs.org/docs/pages/building-your-application/routing/custom-app" class="text-orange-500">커스텀 앱</a>을 사용해야 합니다!
<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">pages/_app.tsx</code> (또는 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">pages/_app.js</code> 만약 당신이 괴물이라면)이라는 파일을 추가합니다.
이 문제를 해결하기 위해 순진한 접근 방식을 시도해 봅시다.
<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">window</code>가 정의되지 않은 경우 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">null</code>을 반환하고, 그렇지 않으면 페이지를 렌더링 합니다.</p><pre><code class="my-4 hljs text-xs language-jsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppProps</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/app&quot;</span>;
<span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params">{ Component, pageProps }: AppProps</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> === <span class="hljs-string">&quot;undefined&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> {<span class="hljs-attr">...pageProps</span>} /&gt;</span></span>;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;</code></pre>
    <h2 id="-hydration-failed" class="text-xl my-4 font-semibold">
      `Hydration failed`
    </h2><p class="my-1 text-sm leading-7 mb-6">페이지를 다시 로드하면 새로운 오류가 표시됩니다.</p><p class="my-1 text-sm leading-7 mb-6"><img class="my-4 border-gray-300 border rounded-sm p-1" src="./assets/hydration_failed.png"></p><p class="my-1 text-sm leading-7 mb-6">Next.js 앱의 페이지를 로드하면 Next.js는 1) 서버에서 사전 렌더링을 시도하고 2) 결과를 브라우저로 전송한 다음 3) 브라우저에서 페이지를 &quot;re-hydrates&quot; 합니다. Re-hydration은 브라우저에서 다시 렌더링하고 서버에서 렌더링한 버전과 비교하는 것을 의미합니다.
두 버전이 일치하지 않으면 React는 오류를 발생시킵니다.</p><p class="my-1 text-sm leading-7 mb-6">좀 더 영리하게 생각해 봅시다.</p><pre><code class="my-4 hljs text-xs language-jsx"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppProps</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/app&quot;</span>;
<span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params">{ Component, pageProps }: AppProps</span>) {
  <span class="hljs-keyword">const</span> [render, setRender] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setRender</span>(<span class="hljs-literal">true</span>), []);
  <span class="hljs-keyword">return</span> render ? <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> {<span class="hljs-attr">...pageProps</span>} /&gt;</span></span> : <span class="hljs-literal">null</span>;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;</code></pre><p class="my-1 text-sm leading-7 mb-6">이 접근 방식은 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">useState</code> 와 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">useEffect</code>를 사용합니다.
Next.js가 서버에서 페이지를 렌더링할 때 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">useEffect</code>를 호출하지 않고 기본값을 사용하여 페이지를 렌더링한 후 결과를 반환합니다.</p><p class="my-1 text-sm leading-7 mb-6">이 페이지가 브라우저에 의해 로드되면 기본값을 사용하여 페이지를 렌더링하는 동일한 작업을 수행합니다.
렌더링의 기본값이 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">false</code>이므로 브라우저는 처음에 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">null</code>을 렌더링합니다.
이는 서버에서 렌더링된 페이지 버전과 일치하기 때문에 좋습니다.</p><p class="my-1 text-sm leading-7 mb-6">그 직후 브라우저는 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">useEffect</code> 호출을 실행하여 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">render</code>를 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">true</code>로 설정합니다.
이제 페이지가 완전한 모습으로 다시 렌더링 됩니다.
처음에는 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">null</code>을 렌더링하는 데 약간의 시간이 낭비되지만, 이는 밀리초 미만의 아주 미세한 시간입니다.</p>
    <h2 id="-404-page-not-found" class="text-xl my-4 font-semibold">
      `404 Page Not Found`
    </h2><p class="my-1 text-sm leading-7 mb-6">React Router와 Next.js 라우터는 이상하고 예상치 못한 방식으로 상호 작용할 수 있습니다.
이 문제를 이해하려면 클라이언트 사이드 라우팅과 &quot;서버 사이드 라우팅&quot;의 차이점을 이해해야 합니다.</p><p class="my-1 text-sm leading-7 mb-6">현재 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">pages/index.tsx</code>는 2개의 &quot;페이지&quot;를 구현하고 있습니다: 홈페이지(<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">/</code>)와 about 페이지 (<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">/about</code>)로 입니다.</p><p class="my-1 text-sm leading-7 mb-6">이렇게 해보세요.</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">localhost:3000</code>로 이동하세요.</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">&quot;About&quot; 링크를 클릭하세요.</p></li></ul><p class="my-1 text-sm leading-7 mb-6">URL이 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">localhost:3000/about</code>으로 변경되고 about &quot;페이지&quot;가 표시됩니다.
좋습니다! 하지만</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">페이지를 새로고침하세요.</p></li></ul><p class="my-1 text-sm leading-7 mb-6">이제 404가 표시됩니다.
왜 그럴까요?
<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">localhost:3000/about</code>은 새로고침하기 전엔 잘 동작했습니다.</p><p class="my-1 text-sm leading-7 mb-6">Next.js의 입장에서는 홈페이지(<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">localhost:3000</code>)가 존재하는 <em>유일한</em> 페이지 입니다.
페이지가 로드되면 react-router가 URL바의 제어권을 장악합니다.
react-router의 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">&lt;Link&gt;</code>를 클릭하면 URL이 프로그래밍 방식으로 변경되지만 페이지가 완전히 새로고침되지는 않습니다.</p><p class="my-1 text-sm leading-7 mb-6">그러나 페이지를 새로 고치면 브라우저는 Next.js에 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">localhost:3000/about</code>에 대한 컨텐츠를 제공하도록 요청합니다.
페이지를 구현하지 않았기 때문에 Next.js는 포기하고 404를 던집니다.</p><p class="my-1 text-sm leading-7 mb-6">해결 방법은 <a href="https://nextjs.org/docs/pages/api-reference/next-config-js/rewrites" class="text-orange-500">Rewrites</a> 입니다!</p><p class="my-1 text-sm leading-7 mb-6">이 기능은 Next.js9.5에서 사용할 수 있게 되었습니다. Rewrites는 &quot;URL 별칭&quot;과 같으며 일부 &quot;source&quot; URL을 다른 &quot;destination&quot; URL에 매핑하도록 Next.js에 지시할 수 있습니다.
<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">next.config.js</code>에 이 설정을 할 수 있습니다(해당 파일이 없는 경우 프로젝트의 루트에 생성해야합니다.)
다음의 내용을 추가합니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-comment">// next.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">rewrites</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> [
      {
        <span class="hljs-attr">source</span>: <span class="hljs-string">&quot;/:any*&quot;</span>,
        <span class="hljs-attr">destination</span>: <span class="hljs-string">&quot;/&quot;</span>,
      },
    ];
  },
};</code></pre><p class="my-1 text-sm leading-7 mb-6">이 rewrite 규칙은 들어오는 모든 요쳥(<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">/:any\*</code>)을 홈페이지(<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">/</code>)에 매핑합니다.</p><p class="my-1 text-sm leading-7 mb-6">이제 서버를 다시 시작하고 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">localhost:3000/about</code>에 접속하면 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">index.tsx</code> 홈페이지가 렌더링 되어야 합니다.</p>
    <h2 id="" class="text-xl my-4 font-semibold">
      클라이언트 사이드 렌더링과 서버 사이드 렌더링 혼합하기
    </h2><p class="my-1 text-sm leading-7 mb-6">주의할 점: 들어오는 요청이 pages 디렉터리의 기존 페이지에 해당하는 경우 Next.js는 이 rewrite 규칙을 무시합니다.
예를 들어, 나중에 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">pages/about.tsx</code>를 추가하면 Next.js는 홈페이지에 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">/about</code>을 다시 작성하는 것을 멈춥니다.</p><p class="my-1 text-sm leading-7 mb-6"><img class="my-4 border-gray-300 border rounded-sm p-1" src="./assets/nextjs_pages.png"></p><p class="my-1 text-sm leading-7 mb-6">정말 멋진 기능입니다! 우선, 추가 구성없이 API Routes를 사용할 수 있습니다.
하지만 더 중요한 것은 SPA, SSR, SSG 패러다임을 마음대로 섞어서 사용할 수 있다는 점입니다!
예를 들어 서버사이드에서 렌더링되는 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">/settings</code>페이지를 추가할 수 있습니다.</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">pages/settings.tsx</code>를 생성하고 구현합니다.</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">getServerSideProps</code> 를 추가합니다.</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">next/link</code> (<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">react-router-dom</code> 이 아닌)의 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">&lt;Link&gt;</code> 컴포넌트를 사용해서 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">/settings</code>로 이동하는 링크를 추가합니다.</p></li></ul><p class="my-1 text-sm leading-7 mb-6">이제 SPA내에서 싱글 서버 사이드 페이지가 생겼습니다!. create-react-app으로는 불가능합니다.🙃</p>
    <h2 id="" class="text-xl my-4 font-semibold">
      정리
    </h2><p class="my-1 text-sm leading-7 mb-6">이 포스팅에 영감을 주고 정보를 준 Tanner Linsley의 CRA에서 Next.js 로 전환하는 방법에 대한 <a href="https://gist.github.com/tannerlinsley/65ac1f0175d79d19762cf06650707830" class="text-orange-500">Github Gist</a>에 감사를 표합니다.</p><p class="my-1 text-sm leading-7 mb-6">제가 사용한 전체 코드는 데모 저장소 <a href="github.com/colinhacks/nextjs-spa" class="text-orange-500">github.com/colinhacks/nextjs-spa</a>에서 확인할 수 있습니다.</p><p class="my-1 text-sm leading-7 mb-6">이 게시물의 &#39;댓글 섹션&#39;은 이 트위터 스레드입니다.
참여하세요! 저는 Next.js, TypeScript, 오픈 소스 소프트웨어 등 거의 모든 것에 대해 토론하는 것을 좋아합니다!</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><a href="https://twitter.com/colinhacks/status/1321871817095684097?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1321871817095684097%7Ctwgr%5E70c95e2373f525c700b50dc06beca3ec0b3a0c1a%7Ctwcon%5Es1_&ref_url=https%3A%2F%2Fcolinhacks.com%2Fessays%2Fbuilding-a-spa-with-nextjs" class="text-orange-500">트위터 스레드</a></p></li></ul><p class="my-1 text-sm leading-7 mb-6">Next.js나 TypeScript에 관심이 있으시다면 <a href="https://twitter.com/colinhacks" class="text-orange-500">트위터 @colinhacks</a>에서 저를 팔로우하세요!
저는 <a href="https://github.com/colinhacks/zod" class="text-orange-500">Zod</a>(TypeScript 유효성 검사 라이브러리)와 <a href="https://github.com/trpc/trpc" class="text-orange-500">tRPC</a>(TypeScript로 종단간 안전한 타입 API를 구축하기 위한 도구)와 같은 오픈소스 도구를 구축하고 유지 관리합니다.
또는 뉴스레터를 구독하여 새 게시물을 게시할 때 알림을 받아보세요!</p>
          </main>
        </div>
        <script src="/dev-blog/scripts/header.js"></script>
      </body>
    </html>
    