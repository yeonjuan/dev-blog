
   <!doctype html>
    <html lang="ko">
      <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width" />
        <title>ES2023에는 자바스크립트에 새로운 배열 복사 메서드가 도입됩니다. (번역) | DevBlog</title>
        <link href="/dev-blog/favicon.ico" rel="shortcut icon">
        <meta name="description" content="ES2023에 도입되는 새로운 배열 메서드의 사용법에 대해서 알아볼 수 있습니다.">
        <link href="/dev-blog/output.css" type="text/css" rel="stylesheet" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
          href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&display=swap"
          rel="stylesheet"
        />
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZBZX7LMVNE"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-ZBZX7LMVNE');
        </script>
        
      <link href="/dev-blog/css/github.min.css" type="text/css" rel="stylesheet" />
    
    
      </head>
      <body>
        <div class="relative">
            
  <style>
        .hamburger {
            cursor: pointer;
            justify-content: space-between;
            flex-direction: column;
        }
        .hamburger > div {
            height: 2px;
            transition: 0.2s ease-out;
            z-index: 999;
        }
        .menuInput:checked ~ .hamburger > div:nth-child(1) {
            transform: translateY(6.5px) rotate(45deg);
        }
        .menuInput:checked ~ .hamburger > div:nth-child(2) {
            opacity: 0;
        }
        .menuInput:checked ~ .hamburger > div:nth-child(3) {
            transform: translateY(-6.5px) rotate(-45deg);
        }
    </style>
  <div id="overlay" class="backdrop-blur-sm bg-black/20 dark:bg-slate-900/80 fixed h-full inset-0 hidden"></div>
  <header class="bg-zinc-800 text-white h-12 fixed flex justify-between items-center w-full px-4">
    <a
      class="w-10 flex items-center justify-center"
      href="https://github.com/yeonjuan/dev-blog"
      target="_blank"
      rel="noopener noreferrer"
    >
      <img
        src="/dev-blog/assets/ic-github.svg"
        alt="go to github"
        width="20"
      >
    </a>
    <span>
      <a href="/dev-blog/">
        DEV BLOG
      </a>
    </span>
    <div class="w-10">
      <input
        id="menu"
        type="checkbox"
        class="menuInput peer sr-only hidden"
        aria-hidden="true"
      >
      <label
        for="menu"
        aria-label="menu button"
        class="hamburger flex flex-col justify-between ml-auto h-[21px] w-[21px] px-[1px] py-[3px] [&>div]:h-[2px] [&>div]:w-[18px] [&>div]:bg-white hover:cursor-pointer"
      >
        <div></div>
        <div></div>
        <div></div>
      </label>
      <nav class="fixed text-black transition-[max-height] duration-200 overflow-hidden max-h-0 top-12 left-[0px] peer-checked:max-h-[200px] bg-white w-full border-b border-black">
        <ul class="p-4">
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/">HOME</a>
          </li>
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/posts/JavaScript">JavaScript</a>
          </li>
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/posts/Review">Review</a>
          </li>
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/posts/Browser">Browser</a>
          </li>
        </ul>
      </nav>
    </div>
  </header>

          <main class="py-2 px-4 pt-10 max-w-3xl m-auto pb-20">
          
            <aside class="mt-14">
              <a href="/dev-blog/" class="hover:underline">Home</a> &gt; <a href="/dev-blog/posts/JavaScript" class="hover:underline">JavaScript</a> &gt; <a href="/dev-blog/posts/JavaScript/es2023-new-array-copying-methods-javascript" class="hover:underline">ES2023에는 자바스크립트에 새로운 배열 복사 메서드가 도입됩니다. (번역)</a>
            </aside>
          
            
    <h1 id="es2023" class="text-2xl my-8 font-bold">
      ES2023에는 자바스크립트에 새로운 배열 복사 메서드가 도입됩니다.
    </h1><blockquote class="border-l-2 border-black pl-2 my-4"><p class="my-1 text-sm leading-7 mb-6">원문: <a href="https://www.sonarsource.com/blog/es2023-new-array-copying-methods-javascript/" class="text-orange-500">https://www.sonarsource.com/blog/es2023-new-array-copying-methods-javascript/</a></p></blockquote><p class="my-1 text-sm leading-7 mb-6"><img class="my-4 border-gray-300 border rounded-sm p-1" src="https://assets-eu-01.kc-usercontent.com/6cc4ce1e-8db0-0171-a6b3-352aa24017de/7a119115-0abd-412f-9587-36c77808db7a/javascript-array-copying-methods_blog-index.webp?w=1200&h=628&auto=format&fit=crop"></p><p class="my-1 text-sm leading-7 mb-6"><a href="https://tc39.es/ecma262/" class="text-orange-500">ECMAScript 2023 스펙</a>이 최근 확정되었습니다.
이번 스펙에는 자바스크립트 프로그램을 더 예측 가능하고 유지 보수하기 쉽도록 하는 데 도움이 되는 배열 객체에 대한 몇 가지 새로운 메서드가 포함되어 있습니다.
<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toSorted</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toReversed</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toSpliced</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">with</code> 메서드를 사용하면, 원본 데이터를 변경하지 않고 복사본을 만들어 변경하는 방식으로 배열에 대한 연산을 수행할 수 있습니다.
그럼 변경된 내용과 프로젝트에서 이를 사용하는 방법을 살펴보겠습니다.</p>
    <h2 id="-mutation" class="text-xl my-4 font-semibold">
      변경(Mutation)과 사이드 이펙트
    </h2><p class="my-1 text-sm leading-7 mb-6">배열 객체에는 몇 가지 이상한 점이 있었습니다.
<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">sort</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">reverse</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">splice</code> 같은 메서드는 원본 배열을 변경합니다.
<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">concat</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">map</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">filter</code> 같은 다른 메서드들은 배열의 복사본을 만들고 복사본에다가 작업을 수행합니다.
객체에 변형을 일으키는 작업을 수행하면 사이드 이펙트가 발생하고, 시스템의 다른 곳에서 예기치 않은 동작이 발생할 수 있습니다.
예를 들어, 배열을 반전시키면 다음과 같은일이 일어납니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> languages = [<span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;TypeScript&quot;</span>, <span class="hljs-string">&quot;CoffeeScript&quot;</span>];
<span class="hljs-keyword">const</span> reversed = languages.<span class="hljs-title function_">reverse</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reversed);
<span class="hljs-comment">// =&gt; [ &#x27;CoffeeScript&#x27;, &#x27;TypeScript&#x27;, &#x27;JavaScript&#x27; ]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(languages);
<span class="hljs-comment">// =&gt; [ &#x27;CoffeeScript&#x27;, &#x27;TypeScript&#x27;, &#x27;JavaScript&#x27; ]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(languages, reversed));
<span class="hljs-comment">// =&gt; true</span></code></pre><p class="my-1 text-sm leading-7 mb-6">보시다시피 원본 배열이 반전되었고 배열을 반전시킨 결과를 새 변수에 할당했지만 두 변수 모두 동일한 배열을 가리키고 있습니다.</p>
    <h2 id="" class="text-xl my-4 font-semibold">
      배열 변경과 리액트
    </h2><p class="my-1 text-sm leading-7 mb-6">배열을 변경하는 배열 메서드와 관련하여 가장 잘 알려진 문제 중 하나는 배열을 리액트 컴포넌트에서 사용할 때입니다.
배열 자체는 동일한 객체이므로 배열을 변경한 다음 새 상태로 설정하면 렌더링이 새로 발생하지 않습니다.
대신에 먼저 배열을 복사하고, 복사본을 수정한 뒤에 새 상태로 설정해야 합니다.
이 때문에 리액트 문서에는 <a href="https://react.dev/learn/updating-arrays-in-state" class="text-orange-500">배열을 업데이트 하는 방법</a>을 설명하는 문서가 있습니다..</p>
    <h2 id="" class="text-xl my-4 font-semibold">
      복사후 변경
    </h2><p class="my-1 text-sm leading-7 mb-6">이 문제를 해결하는 방법은 배열을 먼저 복사한 다음 변경하는 것이었습니다.
배열의 복사본을 만드는 방법에는 다음과 같은 여러 가지가 있습니다. <code class="bg-gray-100 px-1 rounded-md inline-block text-sm"> Array.from</code>, 스프레드 연산자, 인자 없이 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">slice</code> 함수를 호출하는 방법 등이 있습니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> languages = [<span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;TypeScript&quot;</span>, <span class="hljs-string">&quot;CoffeeScript&quot;</span>];
<span class="hljs-keyword">const</span> reversed = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(languages).<span class="hljs-title function_">reverse</span>();
<span class="hljs-comment">// =&gt; [ &#x27;CoffeeScript&#x27;, &#x27;TypeScript&#x27;, &#x27;JavaScript&#x27; ]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(languages);
<span class="hljs-comment">// =&gt; [ &#x27;JavaScript&#x27;, &#x27;TypeScript&#x27;, &#x27;CoffeeScript&#x27; ]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(languages, reversed));
<span class="hljs-comment">// =&gt; false</span></code></pre><p class="my-1 text-sm leading-7 mb-6">해결 방법이 있다는 것은 좋지만, 여러 복사 방법 중 하나를 먼저 수행해야 한다는 것을 기억해야 하는 것은 좋지 않습니다.</p>
    <h2 id="" class="text-xl my-4 font-semibold">
      복사본을 수정하는 새로운 메서드
    </h2><p class="my-1 text-sm leading-7 mb-6">이것이 새로운 메서드들이 생긴 배경입니다.
<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toSorted</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toReversed</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toSpliced</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">with</code> 모두 원본 배열을 복사하고 복사본을 변경한 뒤에 반환합니다.
하나의 함수만 호출하면 되므로 각 작업을 더 쉽게 작성할 수 있고, 배열을 복사하는 네 가지 방법 중 하나를 먼저 분석할 필요가 없으므로 더 쉽게 읽을 수 있습니다.
그래서 각 메서드는 어떤 역할을 할까요?</p>Array.prototype.toSorted<p class="my-1 text-sm leading-7 mb-6"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSorted" class="text-orange-500">toSorted 함수</a>는 정렬된 새로운 배열을 반환합니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> languages = [<span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;TypeScript&quot;</span>, <span class="hljs-string">&quot;CoffeeScript&quot;</span>];
<span class="hljs-keyword">const</span> sorted = languages.<span class="hljs-title function_">toSorted</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sorted);
<span class="hljs-comment">// =&gt; [ &#x27;CoffeeScript&#x27;, &#x27;JavaScript&#x27;, &#x27;TypeScript&#x27; ]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(languages);
<span class="hljs-comment">// =&gt; [ &#x27;JavaScript&#x27;, &#x27;TypeScript&#x27;, &#x27;CoffeeScript&#x27; ]</span></code></pre><p class="my-1 text-sm leading-7 mb-6"><a href="https://philna.sh/blog/2019/08/26/how-not-to-sort-an-array-in-javascript/" class="text-orange-500">sort 함수에는 몇 가지 예상치 못한 동작</a>이 있으며, 복사하는 것 이외에도 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toSorted</code>는 해당 동작을 공유합니다.
숫자나 악센트가 있는 문자를 정렬할 때는 여전히 조심해야합니다.
원하는 결과를 만들기 위해 (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare" class="text-orange-500">String의 localeCompare</a> 같은) <a href="https://rules.sonarsource.com/javascript/rspec-2871/?_gl=1*1a1uyk3*_gcl_au*MzE4NDQ3NTgzLjE2OTUwNDAwOTg.*_ga*MTg0MDkwMjM2My4xNjk1MDQwMDk4*_ga_9JZ0GZ5TC6*MTY5NTY0MDUwMy40LjEuMTY5NTY0MTU1Ny41OC4wLjA." class="text-orange-500">비교함수</a>를 반드시 제공해야 합니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>];
<span class="hljs-keyword">const</span> sorted = numbers.<span class="hljs-title function_">toSorted</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sorted);
<span class="hljs-comment">// =&gt; [ 1, 10, 3, 5, 7 ]</span>
<span class="hljs-keyword">const</span> sortedCorrectly = numbers.<span class="hljs-title function_">toSorted</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sortedCorrectly);
<span class="hljs-comment">// =&gt; [ 1, 3, 5, 7, 10 ]</span></code></pre><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> strings = [<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;äbc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>];
<span class="hljs-keyword">const</span> sorted = strings.<span class="hljs-title function_">toSorted</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sorted);
<span class="hljs-comment">// =&gt; [ &#x27;abc&#x27;, &#x27;def&#x27;, &#x27;äbc&#x27; ]</span>
<span class="hljs-keyword">const</span> sortedCorrectly = strings.<span class="hljs-title function_">toSorted</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-title function_">localeCompare</span>(b));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sortedCorrectly);
<span class="hljs-comment">// =&gt; [ &#x27;abc&#x27;, &#x27;äbc&#x27;, &#x27;def&#x27; ]</span></code></pre>Array.prototype.toReversed<p class="my-1 text-sm leading-7 mb-6"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toReversed" class="text-orange-500"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toReversed 함수</code></a>를 사용하면 반전된 배열을 반환합니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> languages = [<span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;TypeScript&quot;</span>, <span class="hljs-string">&quot;CoffeeScript&quot;</span>];
<span class="hljs-keyword">const</span> reversed = languages.<span class="hljs-title function_">toReversed</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reversed);
<span class="hljs-comment">// =&gt; [ &#x27;CoffeeScript&#x27;, &#x27;TypeScript&#x27;, &#x27;JavaScript&#x27; ]</span></code></pre><p class="my-1 text-sm leading-7 mb-6">Sonar에는 <a href="https://rules.sonarsource.com/javascript/RSPEC-4043/" class="text-orange-500">reverse와 같이 오해의 소지가 있는 메서드 사용을 다루는 규칙</a>이 있습니다.
<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">reverse</code>의 결과를 새 변수에 할당하는 것은 원래 배열도 변이되었기 때문에 오해의 소지가 있습니다.
이제 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toReversed</code> 또는 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toSorted</code>를 사용하여 배열을 복사하고 원본 대신 복사본을 변경할 수 있습니다.</p>Array.prototype.toSpliced<p class="my-1 text-sm leading-7 mb-6"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSpliced" class="text-orange-500"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toSpliced</code> 함수</a>는 기존 버전의 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">splice</code>와는 조금 다릅니다.
<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">splice</code>는 제공된 인덱스에서 요소를 삭제 및 추가하여 기존 배열을 변경하고 배열에서 삭제된 요소가 포함된 배열을 반환합니다.
<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toSpliced</code>는 제거된 요소 없이 새로운 요소가 포함된 새 배열을 반환합니다.
여기 어떻게 동작하는지 보세요:</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> languages = [<span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;TypeScript&quot;</span>, <span class="hljs-string">&quot;CoffeeScript&quot;</span>];
<span class="hljs-keyword">const</span> spliced = languages.<span class="hljs-title function_">toSpliced</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Dart&quot;</span>, <span class="hljs-string">&quot;WebAssembly&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(spliced);
<span class="hljs-comment">// =&gt; [ &#x27;JavaScript&#x27;, &#x27;TypeScript&#x27;, &#x27;Dart&#x27;, &#x27;WebAssembly&#x27; ]</span></code></pre><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">splice</code>를 반환값 때문에 사용한다면 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toSpliced</code>가 대체제가 될수는 없습니다.
원본 배열을 변경하지 않고 삭제된 요소를 알고 싶다면 복사 메서드 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" class="text-orange-500"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">slice</code></a>를 사용해야 합니다.</p><p class="my-1 text-sm leading-7 mb-6">실망스럽게도 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">splice</code>는 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">splice</code>와 다른 인수를 사용합니다.
<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">splice</code>는 인덱스와 해당 인덱스 뒤의 제거할 요소 수를 받지만, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">slice</code>는 시작과 끝의 두 인덱스를 받습니다
<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">splice</code> 대신에 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toSplice</code>를 사용하면서 삭제된 요소도 가져오고 싶다면 다음과 같이 원본 배열에 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toSplice</code> 및 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">slice</code>를 적용하면 됩니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> languages = [<span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;TypeScript&quot;</span>, <span class="hljs-string">&quot;CoffeeScript&quot;</span>];
<span class="hljs-keyword">const</span> startDeletingAt = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> deleteCount = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> spliced = languages.<span class="hljs-title function_">toSpliced</span>(
  startDeletingAt,
  deleteCount,
  <span class="hljs-string">&quot;Dart&quot;</span>,
  <span class="hljs-string">&quot;WebAssembly&quot;</span>
);
<span class="hljs-keyword">const</span> removed = languages.<span class="hljs-title function_">slice</span>(startDeletingAt, startDeletingAt + deleteCount);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(spliced);
<span class="hljs-comment">// =&gt; [ &#x27;JavaScript&#x27;, &#x27;TypeScript&#x27;, &#x27;Dart&#x27;, &#x27;WebAssembly&#x27; ]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(removed);
<span class="hljs-comment">// =&gt; [ &#x27;CoffeeScript&#x27; ]</span></code></pre>Array.prototype.with<p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">with</code> 함수는 배열의 한 요소를 변경하기 위해 대괄호 표기법을 사용하는 것과 같은 복사 기능입니다.
따라서 이렇게 배열을 직접 변경하는 대신</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> languages = [<span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;TypeScript&quot;</span>, <span class="hljs-string">&quot;CoffeeScript&quot;</span>];
languages[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;WebAssembly&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(languages);
<span class="hljs-comment">// =&gt; [ &#x27;JavaScript&#x27;, &#x27;TypeScript&#x27;, &#x27;WebAssembly&#x27; ]</span></code></pre><p class="my-1 text-sm leading-7 mb-6">복사본을 만들어 변경을 할 수 있습니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> languages = [<span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;TypeScript&quot;</span>, <span class="hljs-string">&quot;CoffeeScript&quot;</span>];
<span class="hljs-keyword">const</span> updated = languages.<span class="hljs-title function_">with</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;WebAssembly&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(updated);
<span class="hljs-comment">// =&gt; [ &#x27;JavaScript&#x27;, &#x27;TypeScript&#x27;, &#x27;WebAssembly&#x27; ]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(languages);
<span class="hljs-comment">// =&gt; [ &#x27;JavaScript&#x27;, &#x27;TypeScript&#x27;, CoffeeScript&#x27; ]</span></code></pre>
    <h2 id="" class="text-xl my-4 font-semibold">
      배열뿐만 아니라
    </h2><p class="my-1 text-sm leading-7 mb-6">일반 배열 객체만이 새로운 메서드의 이점을 누릴 수 있는 것은 아닙니다.
<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Int8Array</code>부터 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">BigUint64Array</code>까지 모든 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" class="text-orange-500">TypedArray</a>에 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toSorted</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toReversed</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">with</code>를 사용할 수도 있습니다.
<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">TypedArray</code>에는 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">splice</code> 메서드가 없으므로 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toSpliced</code> 메서드도 없습니다.</p>
    <h2 id="" class="text-xl my-4 font-semibold">
      주의사항
    </h2><p class="my-1 text-sm leading-7 mb-6">위에서 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">map</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">filter</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">concat</code>과 같은 메서드가 이미 복사 작업을 수행한다고 언급했습니다.
하지만 이러한 메서드와 새로운 복사 메서드 사이에는 차이가 있습니다.
내장된 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Array</code> 객체를 확장하고 인스턴스에서 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">map</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">flatMap</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">filter</code> 또는 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">concat</code>을 사용하면 동일한 타입의 새 인스턴스가 반환됩니다.
<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Array</code>를 확장하고 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toSorted</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toReversed</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toSpliced</code>를 사용하는 경우 결과는 다시 일반 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Array</code>가 됩니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> {}
<span class="hljs-keyword">const</span> languages = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArray</span>(<span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;TypeScript&quot;</span>, <span class="hljs-string">&quot;CoffeeScript&quot;</span>);
<span class="hljs-keyword">const</span> upcase = languages.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">language</span>) =&gt;</span> language.<span class="hljs-title function_">toUpperCase</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(upcase <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyArray</span>);
<span class="hljs-comment">// =&gt; true</span>
<span class="hljs-keyword">const</span> reversed = languages.<span class="hljs-title function_">toReversed</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reversed <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyArray</span>);
<span class="hljs-comment">// =&gt; false</span></code></pre><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">MyArray.from</code>을 사용하여 이를 다시 사용자 정의 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Array</code>로 되돌릴 수 있습니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> {}
<span class="hljs-keyword">const</span> languages = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArray</span>(<span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-string">&quot;TypeScript&quot;</span>, <span class="hljs-string">&quot;CoffeeScript&quot;</span>);
<span class="hljs-keyword">const</span> reversed = <span class="hljs-title class_">MyArray</span>.<span class="hljs-title function_">from</span>(languages.<span class="hljs-title function_">toReversed</span>());
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reversed instance <span class="hljs-keyword">of</span> <span class="hljs-title class_">MyArray</span>);
<span class="hljs-comment">// =&gt; true</span></code></pre>
    <h2 id="" class="text-xl my-4 font-semibold">
      지원
    </h2><p class="my-1 text-sm leading-7 mb-6">ECMAScript 2023 사양은 매우 새롭지만 이러한 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#browser_compatibility" class="text-orange-500">새로운 배열 방식에 대한 지원</a>은 이미 잘 이루어지고 있습니다.
Chrome 110, Safari 16.3, Node.js 20, Deno 1.31은 네 가지 방법을 모두 지원하며, <a href="https://github.com/tc39/proposal-change-array-by-copy#implementations" class="text-orange-500">아직 지원하지 않는 플랫폼을 위한 폴리필과 심(shim)</a>을 사용할 수 있습니다.</p>
    <h2 id="javascript" class="text-xl my-4 font-semibold">
      JavaScript 는 계속 개선됩니다.
    </h2><p class="my-1 text-sm leading-7 mb-6">예측 가능한 코드를 더 쉽게 작성할 수 있도록 ECMAScript 표준에 이와 같은 기능이 추가되는 것은 매우 반가운 일입니다.
ES2023에 포함된 <a href="https://github.com/tc39/proposals/blob/HEAD/finished-proposals.md" class="text-orange-500">다른 몇 가지 제안</a>도 있으니 관심이 있으시다면 확인해 보세요.
<a href="https://github.com/tc39/proposals" class="text-orange-500">TC39 제안 레포지토리 전체</a>에서 이 사양에 합류할 예정인 다른 제안서를 확인해보세요.</p>
          </main>
        </div>
        <script src="/dev-blog/scripts/header.js"></script>
      </body>
    </html>
    