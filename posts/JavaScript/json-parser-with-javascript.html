
   <!doctype html>
    <html lang="ko">
      <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width" />
        <title>JavaScript JSON 파서 (번역) | DevBlog</title>
        <link href="/dev-blog/favicon.ico" rel="shortcut icon">
        <meta name="description" content="이 글에서는 JavaScript로 JSON 파서를 구현하는 방법을 소개합니다. JSON 파서를 구현하는 예시를 통해 문법 다이어그램, 파서 구현 방법, 파싱 에러를 처리하는 방법들을 살펴볼 수 있습니다.">
        <meta property="og:image" content="/dev-blog/posts/JavaScript/assets/json-parser-with-javascript.webp" /> 
        <meta property="og:type" content="blog" />
        <meta property="og:title" content="JavaScript JSON 파서 (번역) | DevBlog" /> 
        <meta property="og:description" content="이 글에서는 JavaScript로 JSON 파서를 구현하는 방법을 소개합니다. JSON 파서를 구현하는 예시를 통해 문법 다이어그램, 파서 구현 방법, 파싱 에러를 처리하는 방법들을 살펴볼 수 있습니다." /> 
        <link href="/dev-blog/output.css" type="text/css" rel="stylesheet" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
          href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&display=swap"
          rel="stylesheet"
        />
        <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "BlogPosting",
          "headline": "JavaScript JSON 파서 (번역) | DevBlog",
          "image": [
            "https://yeonjuan.github.io//dev-blog/posts/JavaScript/assets/json-parser-with-javascript.webp",
          ],
            
              "datePublished": "2022-12-12T00:00:00+09:00",
              "dateModified": "2022-12-12T00:00:00+09:00",
              
          "author": [{
              "@type": "Person",
              "name": "YeonJuAn",
              "url": "https://github.com/yeonjuan"
            }]
        }
        </script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZBZX7LMVNE"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-ZBZX7LMVNE');
        </script>
        
      <link href="/dev-blog/css/github.min.css" type="text/css" rel="stylesheet" />
    
    
      </head>
      <body>
        <div class="relative">
            
  <style>
        .hamburger {
            cursor: pointer;
            justify-content: space-between;
            flex-direction: column;
        }
        .hamburger > div {
            height: 2px;
            transition: 0.2s ease-out;
            z-index: 999;
        }
        .menuInput:checked ~ .hamburger > div:nth-child(1) {
            transform: translateY(6.5px) rotate(45deg);
        }
        .menuInput:checked ~ .hamburger > div:nth-child(2) {
            opacity: 0;
        }
        .menuInput:checked ~ .hamburger > div:nth-child(3) {
            transform: translateY(-6.5px) rotate(-45deg);
        }
    </style>
  <div id="overlay" class="backdrop-blur-sm bg-black/20 dark:bg-slate-900/80 fixed h-full inset-0 hidden"></div>
  <header class="bg-zinc-800 text-white h-12 fixed flex justify-between items-center w-full px-4">
    <a
      class="w-10 flex items-center justify-center"
      href="https://github.com/yeonjuan/dev-blog"
      target="_blank"
      rel="noopener noreferrer"
    >
      <img
        src="/dev-blog/assets/ic-github.svg"
        alt="go to github"
        width="20"
      >
    </a>
    <span>
      <a href="/dev-blog/">
        DEV BLOG
      </a>
    </span>
    <div class="w-10">
      <input
        id="menu"
        type="checkbox"
        class="menuInput peer sr-only hidden"
        aria-hidden="true"
      >
      <label
        for="menu"
        aria-label="menu button"
        class="hamburger flex flex-col justify-between ml-auto h-[21px] w-[21px] px-[1px] py-[3px] [&>div]:h-[2px] [&>div]:w-[18px] [&>div]:bg-white hover:cursor-pointer"
      >
        <div></div>
        <div></div>
        <div></div>
      </label>
      <nav class="fixed text-black transition-[max-height] duration-200 overflow-hidden max-h-0 top-12 left-[0px] peer-checked:max-h-[200px] bg-white w-full border-b border-black">
        <ul class="p-4">
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/">HOME</a>
          </li>
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/posts/JavaScript">JavaScript</a>
          </li>
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/posts/Review">Review</a>
          </li>
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/posts/Browser">Browser</a>
          </li>
        </ul>
      </nav>
    </div>
  </header>

          <main class="py-2 px-4 pt-10 max-w-3xl m-auto pb-20">
          
            <aside class="mt-14">
              <a href="/dev-blog/" class="hover:underline">Home</a> &gt; <a href="/dev-blog/posts/JavaScript" class="hover:underline">JavaScript</a> &gt; <a href="/dev-blog/posts/JavaScript/json-parser-with-javascript" class="hover:underline">JavaScript JSON 파서 (번역)</a>
            </aside>
          
            
    <h1 id="javascript-json" class="text-2xl my-8 font-bold">
      JavaScript JSON 파서
    </h1><blockquote class="border-l-2 border-black pl-2 my-4"><p class="my-1 text-sm leading-7 mb-6">이 글은 <a href="https://github.com/tanhauhau" class="text-orange-500">Tan Li Hau</a>가 작성한 <a href="https://lihautan.com/json-parser-with-javascript/" class="text-orange-500">JSON Parser with JavaScript</a>를 번역한 글입니다.</p></blockquote><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><a href="#문법-이해하기" class="text-orange-500">문법 이해하기</a></p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><a href="#파서-구현하기" class="text-orange-500">파서 구현하기</a></p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><a href="#예상치-못한-입력-처리하기" class="text-orange-500">예상치 못한 입력 처리하기</a></p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><a href="#예상치-못한-토큰" class="text-orange-500">예상치 못한 토큰</a></p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><a href="#예상치-못한-문자열의-끝" class="text-orange-500">예상치 못한 문자열의 끝</a></p></li></ul></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><a href="#조금-더-나아가기" class="text-orange-500">조금 더 나아가기</a></p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><a href="#에러-코드와-표준-에러-메시지" class="text-orange-500">에러 코드와 표준 에러 메시지</a></p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><a href="#무엇이-잘못되었는지-더-잘-보여주기" class="text-orange-500">무엇이 잘못되었는지 더 잘 보여주기</a></p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><a href="#에러-복구를-위한-제안" class="text-orange-500">에러 복구를 위한 제안</a></p></li></ul></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><a href="#요약" class="text-orange-500">요약</a></p></li></ul><p class="my-1 text-sm leading-7 mb-6">Cassidoo의 주간 소식지에 실린 이번 주 인터뷰 질문은,</p><blockquote class="border-l-2 border-black pl-2 my-4"><p class="my-1 text-sm leading-7 mb-6">유효한 JSON 문자열을 가져와 객체(또는 선택한 언어가 사용하는 모든 것, 딕셔너리, 맵 등)로 변환하는 함수를 작성합니다.
입력 예제: </p></blockquote><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-title function_">fakeParseJSON</span>(<span class="hljs-string">&#x27;{ &quot;data&quot;: { &quot;fish&quot;: &quot;cake&quot;, &quot;array&quot;: [1,2,3], &quot;children&quot;: [ { &quot;something&quot;: &quot;else&quot; }, { &quot;candy&quot;: &quot;cane&quot; }, { &quot;sponge&quot;: &quot;bob&quot; } ] } } &#x27;</span>)</code></pre><p class="my-1 text-sm leading-7 mb-6">순간, 저는 그저 다음과 같이 쓰고 싶은 유혹을 받았습니다:</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> fakeParseJSON = <span class="hljs-title class_">JSON</span>.<span class="hljs-property">parse</span>;</code></pre><p class="my-1 text-sm leading-7 mb-6">하지만, 생각해 보니, 저는 AST<sup><a href="#footnote_ast" class="text-orange-500">[1]</a></sup>에 관한 글을 꽤 많이 써왔습니다:</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><a href="https://lihautan.com/creating-custom-javascript-syntax-with-babel/" class="text-orange-500">Babel로 커스텀 JavaScript 구문 만들기</a></p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><a href="https://lihautan.com/step-by-step-guide-for-writing-a-babel-transformation/" class="text-orange-500">커스텀 Babel 변환 작성을 위한 단계별 가이드</a></p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><a href="https://lihautan.com/manipulating-ast-with-javascript/" class="text-orange-500">JavaScript로 AST 다루기</a></p></li></ul><p class="my-1 text-sm leading-7 mb-6">AST를 조작하는 방법뿐만 아니라 컴파일러 파이프라인 개요도 다루지만, 파서를 구현하는 방법에 대해서는 많이 다루지 않았습니다.</p><p class="my-1 text-sm leading-7 mb-6">왜냐하면, JavaScript 컴파일러 구현을 글로 표현하는 것은 너무 버거운 작업이기 때문입니다.</p><p class="my-1 text-sm leading-7 mb-6">초조해 하지 마세요.
JSON도 언어입니다.
JSON도 <a href="https://www.json.org/json-en.html" class="text-orange-500">스펙</a>에서 참고할 수 있는 자체 문법을 가지고 있습니다.
JSON 파서를 작성하는데 필요한 지식과 기술은 JS 파서를 작성할 때도 활용할 수 있습니다.</p><p class="my-1 text-sm leading-7 mb-6">그럼, 이제 JSON 파서를 작성해 봅시다!</p>
    <h2 id="" class="text-xl my-4 font-semibold">
      문법 이해하기
    </h2><p class="my-1 text-sm leading-7 mb-6"><a href="https://www.json.org/json-en.html" class="text-orange-500">스펙 문서</a>를 보면 2개의 다이어그램이 있습니다.</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">왼쪽에 <a href="https://en.wikipedia.org/wiki/Syntax_diagram" class="text-orange-500">구문 다이어그램 (또는 철도 다이어그램)</a></p></li></ul><p class="my-1 text-sm leading-7 mb-6"><img class="my-4 border-gray-300 border rounded-sm p-1" alt="" src="./assets/json-parser-object.webp">
<em>이미지 출처: <a href="https://www.json.org/img/object.png" class="text-orange-500">https://www.json.org/img/object.png</a></em></p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">오른쪽에 <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form" class="text-orange-500">Backus–Naur 표기법</a>의 변형인, <a href="https://www.crockford.com/mckeeman.html" class="text-orange-500">McKeeman 표기법</a></p></li></ul><pre><code class="my-4 hljs text-xs language-">json
  element

value
  object
  array
  string
  number
  &quot;true&quot;
  &quot;false&quot;
  &quot;null&quot;

object
  &#x27;{&#x27; ws &#x27;}&#x27;
  &#x27;{&#x27; members &#x27;}&#x27;</code></pre><p class="my-1 text-sm leading-7 mb-6">두 다이어그램은 동일합니다.</p><p class="my-1 text-sm leading-7 mb-6">하나는 시각적이고 하나는 텍스트 기반입니다. 텍스트 기반 문법 구문인 Backus–Naur 표기법은 보통 이 문법을 구문 분석하고 파서를 생성하는 다른 파서에 제공됩니다. 파서 개념에 대해 말하자면... 너무 복잡합니다!</p><p class="my-1 text-sm leading-7 mb-6">이 글에서는, 철도 다이어그램에 초점을 맞출 것입니다. 왜냐하면 시각적이고 저에게 더 익숙하게 보였기 때문입니다.</p><p class="my-1 text-sm leading-7 mb-6">첫 번째 철도 다이어그램을 살펴보겠습니다:</p><p class="my-1 text-sm leading-7 mb-6"><img class="my-4 border-gray-300 border rounded-sm p-1" alt="" src="./assets/json-parser-object.webp">
<em>이미지 출처: <a href="https://www.json.org/img/object.png" class="text-orange-500">https://www.json.org/img/object.png</a></em></p><p class="my-1 text-sm leading-7 mb-6">이것이 JSON에서 <strong>&quot;object&quot;</strong> 에 대한 문법입니다.</p><p class="my-1 text-sm leading-7 mb-6">왼쪽에서 화살표를 따라 시작하고 오른쪽에서 끝납니다.</p><p class="my-1 text-sm leading-7 mb-6">원들은 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">{</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">,</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">:</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">}</code>과 같은 문자이며, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">whitespace</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">string</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">value</code>과 같은 상자들은 다른 문법의 자리를 표시합니다.
그래서 &quot;whitespace&quot;를 파싱하기 위해서는 <strong>&quot;whitespace&quot;</strong> 에 대한 문법을 살펴보아야 합니다.</p><p class="my-1 text-sm leading-7 mb-6">따라서, 객체인 경우 왼쪽부터 시작해서 첫 번째 문자는 열린 괄호여야 합니다, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">{</code>. 그리고 여기서 두 가지 옵션이 있습니다.</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">whitespace</code> → <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">}</code> → 종료, 또는</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">whitespace</code> → <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">string</code> → <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">whitespace</code> → <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">:</code> → <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">value</code> → <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">}</code> → 종료</p></li></ul><p class="my-1 text-sm leading-7 mb-6">물론, &quot;value&quot;에 도달하면 다음 옵션을 선택할 수 있습니다.</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">→ <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">}</code> → 종료, 또는</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">→ <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">,</code> → <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">whitespace</code> → ... → value</p></li></ul><p class="my-1 text-sm leading-7 mb-6">그리고 아래처럼 갈 때까지 계속해서 반복할 수 있습니다:</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">→ <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">}</code>  →  종료</p></li></ul><p class="my-1 text-sm leading-7 mb-6">그럼 이제 철도 다이어그램에 대해 잘 알고 있는 것 같네요. 다음 섹션으로 넘어가겠습니다.</p>
    <h2 id="" class="text-xl my-4 font-semibold">
      파서 구현하기
    </h2><p class="my-1 text-sm leading-7 mb-6">다음과 같은 구조로 시작해 보겠습니다:</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fakeParseJSON</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// TODO</span>
}</code></pre><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">i</code>를 현재 문자의 인덱스로 초기화하고, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">i</code>가 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">str</code>의 끝에 도달하면 종료됩니다.</p><p class="my-1 text-sm leading-7 mb-6"><strong>&quot;object&quot;</strong> 에 대한 문법을 구현해봅시다:</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fakeParseJSON</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-keyword">if</span> (str[i] === <span class="hljs-string">&#x27;{&#x27;</span>) {
    i ++;
    <span class="hljs-title function_">skipWhitespace</span>();

    <span class="hljs-comment">// 만약 `}` 가 아니라면</span>
    <span class="hljs-comment">// string -&gt; whitespace -&gt; &#x27;:&#x27; -&gt; value -&gt; ... 경로를 가게 됩니다.</span>
    <span class="hljs-keyword">while</span> (str[i] !== <span class="hljs-string">&#x27;}&#x27;</span>) {
        <span class="hljs-keyword">const</span> key = <span class="hljs-title function_">parseString</span>();
        <span class="hljs-title function_">skipWhitespace</span>();
        <span class="hljs-title function_">eatColon</span>();
        <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">parseValue</span>();
    }
  }
}</code></pre><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">parseObject</code> 에서 &quot;string&quot;, &quot;whitespace&quot;와 같이 다른 문법의 구문 분석을 호출할 것이며, 그것들을 구현하면, 모든 것이 동작할 것입니다 🤞.</p><p class="my-1 text-sm leading-7 mb-6">한 가지 깜빡한 것은 쉼표(<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">,</code>)에 대한 것입니다. <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">,</code> 는 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">whitespace</code> → <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">string</code> → <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">whitespace</code> → :`` → ... 의 두 번째 루프를 시작하기 전 한 번만 등장합니다.</p><p class="my-1 text-sm leading-7 mb-6">이를 기반으로 다음 행을 추가합니다:</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fakeParseJSON</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">parseObject</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (str[i] === <span class="hljs-string">&#x27;{&#x27;</span>) {
      i++;
      <span class="hljs-title function_">skipWhitespace</span>();

      <span class="hljs-keyword">let</span> initial = <span class="hljs-literal">true</span>;
      <span class="hljs-comment">// &#x27;}&#x27; 가 아니라면</span>
      <span class="hljs-comment">// string -&gt; whitespace -&gt; &#x27;:&#x27; -&gt; value -&gt; ... 경로를 따라갑니다.</span>
      <span class="hljs-keyword">while</span> (str[i] !== <span class="hljs-string">&#x27;}&#x27;</span>) {
        <span class="hljs-keyword">if</span> (!initial) {
          <span class="hljs-title function_">eatComma</span>();
          <span class="hljs-title function_">skipWhitespace</span>();
        }
        <span class="hljs-keyword">const</span> key = <span class="hljs-title function_">parseString</span>();
        <span class="hljs-title function_">skipWhitespace</span>();
        <span class="hljs-title function_">eatColon</span>();
        <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">parseValue</span>();
        initial = <span class="hljs-literal">false</span>;
      }
      <span class="hljs-comment">// &#x27;}&#x27;의 다음 문자로 이동합니다.</span>
      i++;
    }
  }
}</code></pre><p class="my-1 text-sm leading-7 mb-6">몇 가지 네이밍 컨벤션:</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">문법을 기반으로 코드를 파싱하고 반환 값을 사용할 때 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">parseSomething</code> 을 사용합니다.</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">어떤 문자가 존재할 것으로 예상하지만, 그 문자를 사용하지 않을 때 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">eatSomething</code>을 사용합니다.</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">어떤 문자의 존재 여부가 상관없을 때 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">skipSomething</code> 을 사용합니다.</p></li></ul><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">eatComma</code>와 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">eatColon</code>을 구현해 봅시다:</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fakeParseJSON</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">eatComma</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (str[i] !== <span class="hljs-string">&#x27;,&#x27;</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Expected &quot;,&quot;.&#x27;</span>);
    }
    i++;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">eatColon</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (str[i] !== <span class="hljs-string">&#x27;:&#x27;</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Expected &quot;:&quot;.&#x27;</span>);
    }
    i++;
  }
}</code></pre><p class="my-1 text-sm leading-7 mb-6">그래서 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">parseObject</code> 문법 구현을 완료했는데, 이 파싱 함수의 반환 값은 무엇일까요?</p><p class="my-1 text-sm leading-7 mb-6">역시, JavaScript 객체를 반환해야 합니다:</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fakeParseJSON</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">parseObject</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (str[i] === <span class="hljs-string">&#x27;{&#x27;</span>) {
      i++;
      <span class="hljs-title function_">skipWhitespace</span>();

      <span class="hljs-keyword">const</span> result = {};

      <span class="hljs-keyword">let</span> initial = <span class="hljs-literal">true</span>;
      <span class="hljs-comment">// &#x27;}&#x27; 가 아니라면</span>
      <span class="hljs-comment">// string -&gt; whitespace -&gt; &#x27;:&#x27; -&gt; value -&gt; ... 경로를 따라갑니다.</span>
      <span class="hljs-keyword">while</span> (str[i] !== <span class="hljs-string">&#x27;}&#x27;</span>) {
        <span class="hljs-keyword">if</span> (!initial) {
          <span class="hljs-title function_">eatComma</span>();
          <span class="hljs-title function_">skipWhitespace</span>();
        }
        <span class="hljs-keyword">const</span> key = <span class="hljs-title function_">parseString</span>();
        <span class="hljs-title function_">skipWhitespace</span>();
        <span class="hljs-title function_">eatColon</span>();
        <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">parseValue</span>();
        result[key] = value;
        initial = <span class="hljs-literal">false</span>;
      }
      <span class="hljs-comment">// &#x27;}&#x27; 다음 문자로 이동합니다.</span>
      i++;

      <span class="hljs-keyword">return</span> result;
    }
  }
}</code></pre><p class="my-1 text-sm leading-7 mb-6">이제 &quot;object&quot; 문법을 구현하는 것을 보았으니 &quot;array&quot; 문법에 도전해 볼 차례입니다.</p><p class="my-1 text-sm leading-7 mb-6"><img class="my-4 border-gray-300 border rounded-sm p-1" alt="" src="./assets/json-parser-array.webp">
<em>이미지 출처: <a href="https://www.json.org/img/array.png" class="text-orange-500">https://www.json.org/img/array.png</a></em></p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fakeParseJSON</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">parseArray</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (str[i] === <span class="hljs-string">&#x27;[&#x27;</span>) {
      i++;
      <span class="hljs-title function_">skipWhitespace</span>();

      <span class="hljs-keyword">const</span> result = [];
      <span class="hljs-keyword">let</span> initial = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">while</span> (str[i] !== <span class="hljs-string">&#x27;]&#x27;</span>) {
        <span class="hljs-keyword">if</span> (!initial) {
          <span class="hljs-title function_">eatComma</span>();
        }
        <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">parseValue</span>();
        result.<span class="hljs-title function_">push</span>(value);
        initial = <span class="hljs-literal">false</span>;
      }
      <span class="hljs-comment">// &#x27;]&#x27; 다음 문자로 이동합니다.</span>
      i++;
      <span class="hljs-keyword">return</span> result;
    }
  }
}</code></pre><p class="my-1 text-sm leading-7 mb-6">이제, 조금 더 흥미로운 문법인 &quot;value&quot;로 넘어갑니다:</p><p class="my-1 text-sm leading-7 mb-6"><img class="my-4 border-gray-300 border rounded-sm p-1" alt="" src="./assets/json-parser-value.webp">
<em>이미지 출처: <a href="https://www.json.org/img/value.png" class="text-orange-500">https://www.json.org/img/value.png</a></em></p><p class="my-1 text-sm leading-7 mb-6">value는 &quot;whitespace&quot;로 시작하고, &quot;string&quot;, &quot;number&quot;, &quot;object&quot;, &quot;array&quot;, &quot;true&quot;, &quot;false&quot; 또는 &quot;null&quot; 모두 다음에 오고, &quot;whitespace&quot;로 끝이 납니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fakeParseJSON</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">parseValue</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">skipWhitespace</span>();
    <span class="hljs-keyword">const</span> value =
      <span class="hljs-title function_">parseString</span>() ??
      <span class="hljs-title function_">parseNumber</span>() ??
      <span class="hljs-title function_">parseObject</span>() ??
      <span class="hljs-title function_">parseArray</span>() ??
      <span class="hljs-title function_">parseKeyword</span>(<span class="hljs-string">&#x27;true&#x27;</span>, <span class="hljs-literal">true</span>) ??
      <span class="hljs-title function_">parseKeyword</span>(<span class="hljs-string">&#x27;false&#x27;</span>, <span class="hljs-literal">false</span>) ??
      <span class="hljs-title function_">parseKeyword</span>(<span class="hljs-string">&#x27;null&#x27;</span>, <span class="hljs-literal">null</span>);
    <span class="hljs-title function_">skipWhitespace</span>();
    <span class="hljs-keyword">return</span> value;
  }
}
</code></pre><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">??</code> 은 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing" class="text-orange-500">nullish 병합 연산자</a>인데, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">||</code>처럼 기본값을 지정하는 데 사용하지만, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">foo || default</code>에서  <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">||</code>는 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">foo</code> 가 falsy 일 때 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">default</code>를 반환하는 반면 nullish 병합 연산자는 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">foo</code>가 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">null</code> 또는 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">undefined</code>일 때 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">default</code>를 반환합니다.</p><p class="my-1 text-sm leading-7 mb-6">parseKeyword는 현재 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">str.slice(i)</code> 가 키워드 문자열과 일치하는지 확인하고, 일치하면 키워드 값을 반환합니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fakeParseJSON</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">parseKeyword</span>(<span class="hljs-params">name, value</span>) {
    <span class="hljs-keyword">if</span> (str.<span class="hljs-title function_">slice</span>(i, i + name.<span class="hljs-property">length</span>) === name) {
      i += name.<span class="hljs-property">length</span>;
      <span class="hljs-keyword">return</span> value;
    }
  }
}</code></pre><p class="my-1 text-sm leading-7 mb-6">여기까지 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">parseValue</code>였습니다!</p><p class="my-1 text-sm leading-7 mb-6">아직 3개의 문법이 더 남아 있지만, 이만 줄이고 다음의 CodeSandBox에서 구현할 것입니다: </p><p class="my-1 text-sm leading-7 mb-6"><a href="https://codesandbox.io/embed/json-parser-k4c3w" class="text-orange-500">https://codesandbox.io/embed/json-parser-k4c3w</a></p><p class="my-1 text-sm leading-7 mb-6">모든 문법을 구현한 후에, 이제 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">parseValue</code>에 의해 반환되는 json의 값을 반환합니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fakeParseJSON</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">parseValue</span>();

  <span class="hljs-comment">// ...</span>
}</code></pre><p class="my-1 text-sm leading-7 mb-6">바로 이겁니다!</p><p class="my-1 text-sm leading-7 mb-6">지금까지는 모두 순조로운 부분이었습니다. 어떤 까다로운 부분들이 있을까요?</p>
    <h2 id="" class="text-xl my-4 font-semibold">
      예상치 못한 입력 처리하기
    </h2><p class="my-1 text-sm leading-7 mb-6">우리는 훌륭한 개발자로서 예외 사항도 우아하게 처리할 수 있어야 합니다.
파서의 경우, 개발자에게 적절한 오류 메시지를 출력함으로써 예외 사항을 처리할 수 있습니다.</p><p class="my-1 text-sm leading-7 mb-6">가장 일반적인 두 가지 오류 사례를 살펴보겠습니다.</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">예상치 못한 토큰</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">예상치 못한 문자열의 끝</p></li></ul>
    <h2 id="" class="text-xl my-4 font-semibold">
      예상치 못한 토큰
    </h2>
    <h2 id="" class="text-xl my-4 font-semibold">
      예상치 못한 문자열의 끝
    </h2><p class="my-1 text-sm leading-7 mb-6">모든 while 루프에서, 예를 들어 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">parseObject</code>의 while 루프를 보면:</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fakeParseJSON</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">parseObject</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">while</span>(str[i] !== <span class="hljs-string">&#x27;}&#x27;</span>) {</code></pre><p class="my-1 text-sm leading-7 mb-6">문자열의 길이를 벗어난 문자에 접근하지 않도록 해야 합니다.
이 문제는 문자열이 예기치 않게 종료되었을 때 발생하며, 이 예에서는 여전히 닫는 문자 &quot;}&quot;를 기다리고 있습니다:</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fakeParseJSON</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">parseObject</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">while</span> (i &lt; str.<span class="hljs-property">length</span> &amp;&amp; str[i] !== <span class="hljs-string">&#x27;}&#x27;</span>) {
      <span class="hljs-comment">// ...</span>
    }
    <span class="hljs-title function_">checkUnexpectedEndOfInput</span>();

    <span class="hljs-comment">// &#x27;}&#x27; 의 다음 문자로 이동</span>
    i++;

    <span class="hljs-keyword">return</span> result;
  }
}</code></pre>
    <h2 id="" class="text-xl my-4 font-semibold">
      조금 더 나아가기
    </h2><p class="my-1 text-sm leading-7 mb-6">여러분의 주니어 개발자 때를 기억하시나요? 암호 같은 메시지와 함께 문법 에러를 만날 때마다, 무엇이 잘못되었는지 전혀 알지 못하시진 않으셨나요?</p><p class="my-1 text-sm leading-7 mb-6">이제 더 경험이 쌓였으니, 이 순환과 소리 지르는 것을 멈추고</p><pre><code class="my-4 hljs text-xs language-bash">Unexpected token <span class="hljs-string">&quot;a&quot;</span></code></pre><p class="my-1 text-sm leading-7 mb-6">사용자가 화면을 보며 당황하게 할 때입니다.</p><p class="my-1 text-sm leading-7 mb-6">소리를 지르는 것보다 오류 메시지를 처리하는 데 더 좋은 방법이 많이 있습니다.
다음은 파서에 추가하는 것을 고려할 수 있는 몇 가지 사항입니다.</p>에러 코드와 표준 에러 메시지<p class="my-1 text-sm leading-7 mb-6">이것은 사용자가 Google에 도움을 요청할 때 표준 키워드로 유용합니다.</p><pre><code class="my-4 hljs text-xs language-">// 이것보단
Unexpected token &quot;a&quot;
Unexpected end of input

// 이렇게 보여주세요
JSON_ERROR_001 Unexpected token &quot;a&quot;
JSON_ERROR_002 Unexpected end of input</code></pre>무엇이 잘못되었는지 더 잘 보여주기<p class="my-1 text-sm leading-7 mb-6">Babel과 같은 파서는, 코드 프레임을 보여줍니다.
코드 프레임은 밑줄, 화살표 또는 잘못된 부분이 강조 표시된 코드의 일부분입니다.</p><pre><code class="my-4 hljs text-xs language-bash">// 이것보단
Unexpected token <span class="hljs-string">&quot;a&quot;</span> at position 5

// 이렇게 보여주세요
{ <span class="hljs-string">&quot;b&quot;</span>a
      ^
JSON_ERROR_001 Unexpected token <span class="hljs-string">&quot;a&quot;</span></code></pre><p class="my-1 text-sm leading-7 mb-6">코드의 일부분을 출력하는 방법에 대한 예:</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fakeParseJSON</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">printCodeSnippet</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">from</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, i - <span class="hljs-number">10</span>);
    <span class="hljs-keyword">const</span> trimmed = <span class="hljs-keyword">from</span> &gt; <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> padding = (trimmed ? <span class="hljs-number">3</span> : <span class="hljs-number">0</span>) + (i - <span class="hljs-keyword">from</span>);
    <span class="hljs-keyword">const</span> snippet = [
      (trimmed ? <span class="hljs-string">&#x27;...&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>) + str.<span class="hljs-title function_">slice</span>(<span class="hljs-keyword">from</span>, i + <span class="hljs-number">1</span>),
      <span class="hljs-string">&#x27; &#x27;</span>.<span class="hljs-title function_">repeat</span>(padding) + <span class="hljs-string">&#x27;^&#x27;</span>,
      <span class="hljs-string">&#x27; &#x27;</span>.<span class="hljs-title function_">repeat</span>(padding) + message,
    ].<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(snippet);
  }
}</code></pre>에러 복구를 위한 제안<p class="my-1 text-sm leading-7 mb-6">가능하다면, 무엇이 잘못되었는지 설명하고 해결 방법을 제안하세요.</p><pre><code class="my-4 hljs text-xs language-bash">// 이것보단
Unexpected token <span class="hljs-string">&quot;a&quot;</span> at position 5

// 이렇게 보여주세요
{ <span class="hljs-string">&quot;b&quot;</span>a
      ^
JSON_ERROR_001 Unexpected token <span class="hljs-string">&quot;a&quot;</span>.
Expecting a <span class="hljs-string">&quot;:&quot;</span> over here, eg:
{ <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-string">&quot;bar&quot;</span> }
      ^
You can learn more about valid JSON string <span class="hljs-keyword">in</span> http://goo.gl/xxxxx</code></pre><p class="my-1 text-sm leading-7 mb-6">가능하면, 파서가 지금까지 수집한 컨텍스트를 기반으로 제안을 제공하세요.</p><pre><code class="my-4 hljs text-xs language-bash">fakeParseJSON(<span class="hljs-string">&#x27;&quot;Lorem ipsum&#x27;</span>);

// 이것보단
Expecting a `<span class="hljs-string">&quot;` over here, eg:
&quot;</span>Foo Bar<span class="hljs-string">&quot;
        ^

// 이렇게 보여주세요
Expecting a `&quot;</span>` over here, eg:
<span class="hljs-string">&quot;Lorem ipsum&quot;</span>
            ^</code></pre><p class="my-1 text-sm leading-7 mb-6">컨텍스트를 바탕으로 한 제안은 더 공감할 수 있고 실행할 수 있는 것처럼 느껴질 것입니다.</p><p class="my-1 text-sm leading-7 mb-6">다음 모든 제안 사항을 염두에 두고 업데이트된 CodeSandBox를 확인하세요.</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">의미 있는 에러 메시지</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">실패 지점의 에러를 가리키는 코드 스니펫</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">에러 복구를 위한 제공</p></li></ul><p class="my-1 text-sm leading-7 mb-6"><a href="https://codesandbox.io/embed/json-parser-hjwxk" class="text-orange-500">https://codesandbox.io/embed/json-parser-hjwxk</a></p><p class="my-1 text-sm leading-7 mb-6">또한, Elm이 어떻게 Elm 컴파일러의 UX 문제를 개선하는지에 대한 <a href="https://twitter.com/czaplic" class="text-orange-500">Evan Czaplicki</a>의 <a href="https://elm-lang.org/news/compiler-errors-for-humans" class="text-orange-500">사람을 위한 컴파일러 에러</a>를 읽어보세요.</p>
    <h2 id="" class="text-xl my-4 font-semibold">
      요약
    </h2><p class="my-1 text-sm leading-7 mb-6">파서를 구현하기 위해서는 문법부터 시작해야 합니다.</p><p class="my-1 text-sm leading-7 mb-6">철도 다이어그램이나 Backus-Naur 표기법으로 문법을 공식화할 수 있습니다.
문법을 설계하는 것이 가장 어려운 단계입니다.</p><p class="my-1 text-sm leading-7 mb-6">문법에 익숙해지면, 이를 기반으로 파서 구현을 시작할 수 있습니다.</p><p class="my-1 text-sm leading-7 mb-6">에러 처리는 중요하며, 더 중요한 것은 사용자가 에러 메시지를 수정하는 방법을 알 수 있도록 의미 있는 에러 메시지를 사용하는 것입니다.</p><p class="my-1 text-sm leading-7 mb-6">이제 간단한 파서가 어떻게 구현되는지 알았으니, 좀 더 복잡한 파서를 살펴봐야 할 때입니다. </p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><a href="https://github.com/babel/babel/tree/master/packages/babel-parser" class="text-orange-500">Babel 파서</a></p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><a href="https://github.com/sveltejs/svelte/tree/master/src/compiler/parse" class="text-orange-500">Svelte 파서</a></p></li></ul><p class="my-1 text-sm leading-7 mb-6">마지막으로, <a href="https://twitter.com/cassidoo" class="text-orange-500">@cassidoo</a>를 팔로우하세요. 그녀의 주간 소식지는 굉장합니다!</p><hr>
<ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><a name="footnote_ast">AST</a>: Abstract Syntax Tree의 약자로 소스 코드를 분석해 트리 형태로 나타낸 데이터 구조이다.</p></li></ul>
          </main>
        </div>
        <script src="/dev-blog/scripts/header.js"></script>
      </body>
    </html>
    