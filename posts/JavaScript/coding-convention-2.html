
   <!doctype html>
    <html lang="ko">
      <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width" />
        <title>코딩 컨벤션 업무를 하며 알게 된 것들 - 2 | DevBlog</title>
        <link href="/dev-blog/favicon.ico" rel="shortcut icon">
        <meta name="description" content="이전 글에 이어서 Javascript 코딩 컨벤션 관련 업무를 하며 ESLint 규칙을 통해 알게 된 점을 정리해 보았습니다.">
        <meta property="og:image" content="/dev-blog/posts/JavaScript/assets/coding-convention.png" /> 
        <meta property="og:type" content="blog" />
        <meta property="og:title" content="코딩 컨벤션 업무를 하며 알게 된 것들 - 2 | DevBlog" /> 
        <meta property="og:description" content="이전 글에 이어서 Javascript 코딩 컨벤션 관련 업무를 하며 ESLint 규칙을 통해 알게 된 점을 정리해 보았습니다." /> 
        <link href="/dev-blog/output.css" type="text/css" rel="stylesheet" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
          href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&display=swap"
          rel="stylesheet"
        />
        <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "BlogPosting",
          "headline": "코딩 컨벤션 업무를 하며 알게 된 것들 - 2 | DevBlog",
          "image": [
            "https://yeonjuan.github.io//dev-blog/posts/JavaScript/assets/coding-convention.png"
          ],
            
              "datePublished": "2023-01-01T00:00:00+09:00",
              "dateModified": "2023-01-01T00:00:00+09:00",
              
          "author": [{
              "@type": "Person",
              "name": "YeonJuAn",
              "url": "https://github.com/yeonjuan"
            }]
        }
        </script>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZBZX7LMVNE"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-ZBZX7LMVNE');
        </script>
        
      <link href="/dev-blog/css/github.min.css" type="text/css" rel="stylesheet" />
    
    
      </head>
      <body>
        <div class="relative">
            
  <style>
        .hamburger {
            cursor: pointer;
            justify-content: space-between;
            flex-direction: column;
        }
        .hamburger > div {
            height: 2px;
            transition: 0.2s ease-out;
            z-index: 999;
        }
        .menuInput:checked ~ .hamburger > div:nth-child(1) {
            transform: translateY(6.5px) rotate(45deg);
        }
        .menuInput:checked ~ .hamburger > div:nth-child(2) {
            opacity: 0;
        }
        .menuInput:checked ~ .hamburger > div:nth-child(3) {
            transform: translateY(-6.5px) rotate(-45deg);
        }
    </style>
  <div id="overlay" class="backdrop-blur-sm bg-black/20 dark:bg-slate-900/80 fixed h-full inset-0 hidden"></div>
  <header class="bg-zinc-800 text-white h-12 fixed flex justify-between items-center w-full px-4">
    <a
      class="w-10 flex items-center justify-center"
      href="https://github.com/yeonjuan/dev-blog"
      target="_blank"
      rel="noopener noreferrer"
    >
      <img
        src="/dev-blog/assets/ic-github.svg"
        alt="go to github"
        width="20"
      >
    </a>
    <span>
      <a href="/dev-blog/">
        DEV BLOG
      </a>
    </span>
    <div class="w-10">
      <input
        id="menu"
        type="checkbox"
        class="menuInput peer sr-only hidden"
        aria-hidden="true"
      >
      <label
        for="menu"
        aria-label="menu button"
        class="hamburger flex flex-col justify-between ml-auto h-[21px] w-[21px] px-[1px] py-[3px] [&>div]:h-[2px] [&>div]:w-[18px] [&>div]:bg-white hover:cursor-pointer"
      >
        <div></div>
        <div></div>
        <div></div>
      </label>
      <nav class="fixed text-black transition-[max-height] duration-200 overflow-hidden max-h-0 top-12 left-[0px] peer-checked:max-h-[200px] bg-white w-full border-b border-black">
        <ul class="p-4">
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/">HOME</a>
          </li>
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/posts/JavaScript">JavaScript</a>
          </li>
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/posts/Review">Review</a>
          </li>
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/posts/Browser">Browser</a>
          </li>
        </ul>
      </nav>
    </div>
  </header>

          <main class="py-2 px-4 pt-10 max-w-3xl m-auto pb-20">
          
            <aside class="mt-14">
              <a href="/dev-blog/" class="hover:underline">Home</a> &gt; <a href="/dev-blog/posts/JavaScript" class="hover:underline">JavaScript</a> &gt; <a href="/dev-blog/posts/JavaScript/coding-convention-2" class="hover:underline">코딩 컨벤션 업무를 하며 알게 된 것들 - 2</a>
            </aside>
          
            <!--meta
title: 코딩 컨벤션 업무를 하며 알게 된 것들
description: 코딩 컨벤션, 스타일가이드를 만들며 알게된 내용에 대해 정리한 글.
keywords: 코딩 컨벤션, ESLint, StyleGuide
-->


    <h1 id="-2" class="text-2xl my-8 font-bold">
      코딩 컨벤션 업무를 하며 알게 된 것들 - 2
    </h1><p class="my-1 text-sm leading-7 mb-6">이전 글에 이어서 Javascript 코딩 컨벤션 관련 업무를 하며 <a href="https://eslint.org/" class="text-orange-500">ESLint</a> 규칙을 통해 알게 된 점을 정리해 보았습니다.</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">no-prototype-builtins</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">no-return-await</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">comma-dangle</p></li></ul>
    <h2 id="1-no-prototype-builtins" class="text-xl my-4 font-semibold">
      1. no-prototype-builtins
    </h2><p class="my-1 text-sm leading-7 mb-6"><a href="https://eslint.org/docs/rules/no-prototype-builtins" class="text-orange-500">ESLint: no-prototype-builtins</a> 규칙은 Object.prototype의 builtin으로 제공되는 메서드를 객체에서 직접 호출하지 않도록 하는 규칙입니다. Object.prototype의 builtin 메서드는 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">hasOwnProperty</code>, <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">isPrototypeOf</code> 등이 있고 다음과 같은 방법으로 호출할 수 있습니다.</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">객체에서 직접 호출하는 방법</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">Object.prototype 을 이용하여 호출하는 방법</p></li></ul><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;joah&#x27;</span>,
}

<span class="hljs-comment">//  1. 객체에서 직접 호출</span>
obj.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 2. Object.prototype을 이용해 호출</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-comment">// true</span></code></pre><p class="my-1 text-sm leading-7 mb-6">no-prototype-builtins 규칙에서 객체에서 builtin 메서드를 직접 호출하지 않도록 하는 이유는 다음과 같습니다.</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><strong>Object.create(null)</strong></p><p class="my-1 text-sm leading-7 mb-6">ECMAScript 5.1에서 추가된 Object.create 메서드에 null을 인자로 주어 객체를 생성하게 되면 Object.prototype을 상속받지 않게 됩니다.</p><pre><code class="my-4 hljs text-xs language-js"> <span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);
 obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;joah&#x27;</span>;

 obj.<span class="hljs-property">hasOwnProperty</span>; <span class="hljs-comment">// undefined</span>
 obj.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-comment">// Uncaught TypeError</span>
 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-comment">// true</span></code></pre><p class="my-1 text-sm leading-7 mb-6">따라서 위와 같이 Object.create(null)로 만든 객체에서 builtin 메서드를 직접 호출하게 된다면 에러를 발생시킵니다.</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6"><strong>속성이 builtin 메서드를 감추는 경우</strong></p><p class="my-1 text-sm leading-7 mb-6">객체에 builtin으로 제공되는 메서드와 같은 이름의 키를 객체가 가지고 있다면 예상한 대로 동작하지 않을 수 있습니다.</p><pre><code class="my-4 hljs text-xs language-js"> <span class="hljs-keyword">const</span> badJSON = {
   <span class="hljs-string">&#x27;hasOwnProperty&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>,
   <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;joah&#x27;</span>
 }

 <span class="hljs-comment">// ...</span>

 badJSON.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-comment">// Uncaught TypeError</span>
 <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(badJSON, <span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-comment">// true</span></code></pre><p class="my-1 text-sm leading-7 mb-6">예를 들어 위와 같이 악의적인 클라이언트가 builtin 메서드를 감춘 형태의 JSON을 보내는 경우, 객체에서 직접 메서드를 사용해 처리한다면 에러를 발생시킬 수 있습니다.
이런 이유로 no-prototype-builtins 규칙은 builtin 메서드 사용시 Object.prototype을 활용하도록 권합니다.</p></li></ul>
    <h2 id="2-no-return-await" class="text-xl my-4 font-semibold">
      2. no-return-await
    </h2><p class="my-1 text-sm leading-7 mb-6"><a href="https://eslint.org/docs/rules/no-return-await" class="text-orange-500">ESLint: no-return-await</a> 규칙은 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">async function</code> 내부에서 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">return await</code>을 하지 않도록 하는 규칙입니다. 예를 들어 다음과 같은 경우 입니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getSomePromise</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncCall</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">getSomePromise</span>(); <span class="hljs-comment">// no-return-await 규칙에 걸린다.</span>
}</code></pre><p class="my-1 text-sm leading-7 mb-6">이 규칙에서 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">return await</code>을 잡아내는 이유는 async 키워드를 붙힌 function은 promise를 반환하기 때문입니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getSomePromise</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncCall</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// ...</span>

  <span class="hljs-comment">// (1) promise가 fulfill 되기를 기다렸다가, 값을 반환함</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">getSomePromise</span>();
  <span class="hljs-comment">// (2) async로 선언되었기 때문에 promise가 반환됨</span>
}

<span class="hljs-comment">/* 어디선가 asyncCall()을 호출할 때, */</span>.
<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// (3) promise가 fulfill 되기를 기다렸다가, 값을 반환함</span>
<span class="hljs-keyword">const</span> value = <span class="hljs-keyword">await</span> <span class="hljs-title function_">asynCall</span>();

<span class="hljs-comment">// ...</span></code></pre><p class="my-1 text-sm leading-7 mb-6">위 코드를 보면 (1), (3)이 중복되는 과정이라는 것을 알 수 있습니다.</p><pre><code class="my-4 hljs text-xs language-">(1). async function 내부에서 await으로 promise가 fulfill 되기를 기다린 후
(2). fulfill된 값을 다시 promise로 감싸서 반환하고,
(3). asynCall()을 사용하는 곳에서 await으로 promise가 fulfill 되기를 기다리게 됩니다.</code></pre><p class="my-1 text-sm leading-7 mb-6">비록 성능상에 큰 차이가 발생하지는 않지만 불필요한 작업이기 때문에 ESLint에서 걸러낼수 있는 규칙으로 제공하고 있습니다.
하지만 이 규칙에서도 return await을 허용하는 경우가 있습니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getSomePromise</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncCall</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">getSomePromise</span>();
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-comment">// ...</span>
  }
}</code></pre><p class="my-1 text-sm leading-7 mb-6">바로 위와 같이 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">try catch</code>로 return await을 감쌀 때입니다. await 뒤에 온 promise가 reject될 경우 Error를 throw 합니다. 그리고 그 에러 처리를 try catch를 통해 async 함수 내부에서 처리할 수 있습니다. 때문에 no-return-await 규칙을 사용하더라도 try catch로 감싼 경우는 통과하게 됩니다.</p>
    <h2 id="3-comma-dangle" class="text-xl my-4 font-semibold">
      3. comma-dangle
    </h2><p class="my-1 text-sm leading-7 mb-6"><a href="https://eslint.org/docs/rules/comma-dangle" class="text-orange-500">ESLint: comma-dangle</a> 규칙은 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Trailing_commas" class="text-orange-500">trailing-comma</a>를 사용하도록 설정할 수 있는 규칙입니다. trailing-comma는 object나 array의 값, function의 매개변수 등을 나타낼 때 마지막에 콤마(,)를 하나 더 추가하는 것을 뜻합니다. 아래는 trailing-comma의 예시 입니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,
  <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-comment">// 콤마(,)가 추가 되어있다.</span>
}

<span class="hljs-comment">// 매개변수 마지막에 콤마(,)가 추가되어 있다.</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a, b, </span>) {} </code></pre><p class="my-1 text-sm leading-7 mb-6">처음에 규칙을 사용하기만 할 때는 단순한 스타일을 일치시키기 위한 용도인 줄만 알았습니다. 하지만 trailing-comma를 사용함으로써 얻는 장점이 있습니다.
여러 줄로 이루어진 값을 수정할 때, 삭제/추가해야 할 줄만 수정할 수 있다는 점 입니다. 이 장점 덕분에 형상관리 툴에서 수정사항을 비교하기 쉽습니다.</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">trailing-comma를 사용하지 않았을 때</p><p class="my-1 text-sm leading-7 mb-6"><img class="my-4 border-gray-300 border rounded-sm p-1" alt="comma-dangle-1" src="./assets/comma-dangle-1.png"></p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">trailing-comma를 사용했을 때</p><p class="my-1 text-sm leading-7 mb-6"><img class="my-4 border-gray-300 border rounded-sm p-1" alt="comma-dangle-2" src="./assets/comma-dangle-2.png"></p></li></ul><p class="my-1 text-sm leading-7 mb-6">위와 같이 형상관리 툴의 diff 기능 이용시, trailing-comma를 사용하지 않는다면 콤마가 추가된 라인까지 수정으로 표시됩니다.
trailing-comma를 사용시 추가, 삭제가 된 라인만 표시되게 되어 더 깔끔한 비교 결과를 확인할 수 있습니다.</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">IE6/7/9 Quirks mode 에서는 trailing-comma 가 문제를 일으킬 수 있습니다.</p></li></ul>
          </main>
        </div>
        <script src="/dev-blog/scripts/header.js"></script>
      </body>
    </html>
    