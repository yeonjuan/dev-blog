
   <!doctype html>
    <html lang="ko">
      <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width" />
        <title>Well-Known symbols (번역) | DevBlog</title>
        <link href="/dev-blog/favicon.ico" rel="shortcut icon">
        <meta name="description" content="Well-Known 심볼에 대해 들어보셨나요? Well-Known 심볼은 ECMAScript 스펙에 정의되어 있는 특별한 심볼들인데요. 자바스크립트에서 기본적으로 제공되는 기능을 확장 및 변경할 수 있도록 해줍니다. 이 글에서 Well-Known 심볼 각각에 대한 설명과 예제 코드를 통해 사용법을 알아볼 수 있습니다.">
        <link href="/dev-blog/output.css" type="text/css" rel="stylesheet" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
          href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&display=swap"
          rel="stylesheet"
        />
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZBZX7LMVNE"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-ZBZX7LMVNE');
        </script>
        
      <link href="/dev-blog/css/github.min.css" type="text/css" rel="stylesheet" />
    
    
      </head>
      <body>
        <div class="relative">
            
  <style>
        .hamburger {
            cursor: pointer;
            justify-content: space-between;
            flex-direction: column;
        }
        .hamburger > div {
            height: 2px;
            transition: 0.2s ease-out;
            z-index: 999;
        }
        .menuInput:checked ~ .hamburger > div:nth-child(1) {
            transform: translateY(6.5px) rotate(45deg);
        }
        .menuInput:checked ~ .hamburger > div:nth-child(2) {
            opacity: 0;
        }
        .menuInput:checked ~ .hamburger > div:nth-child(3) {
            transform: translateY(-6.5px) rotate(-45deg);
        }
    </style>
  <div id="overlay" class="backdrop-blur-sm bg-black/20 dark:bg-slate-900/80 fixed h-full inset-0 hidden"></div>
  <header class="bg-zinc-800 text-white h-12 fixed flex justify-between items-center w-full px-4">
    <a
      class="w-10 flex items-center justify-center"
      href="https://github.com/yeonjuan/dev-blog"
      target="_blank"
      rel="noopener noreferrer"
    >
      <img
        src="/dev-blog/assets/ic-github.svg"
        alt="go to github"
        width="20"
      >
    </a>
    <span>
      <a href="/dev-blog/">
        DEV BLOG
      </a>
    </span>
    <div class="w-10">
      <input
        id="menu"
        type="checkbox"
        class="menuInput peer sr-only hidden"
        aria-hidden="true"
      >
      <label
        for="menu"
        aria-label="menu button"
        class="hamburger flex flex-col justify-between ml-auto h-[21px] w-[21px] px-[1px] py-[3px] [&>div]:h-[2px] [&>div]:w-[18px] [&>div]:bg-white hover:cursor-pointer"
      >
        <div></div>
        <div></div>
        <div></div>
      </label>
      <nav class="fixed text-black transition-[max-height] duration-200 overflow-hidden max-h-0 top-12 left-[0px] peer-checked:max-h-[200px] bg-white w-full border-b border-black">
        <ul class="p-4">
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/">HOME</a>
          </li>
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/posts/JavaScript">JavaScript</a>
          </li>
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/posts/Review">Review</a>
          </li>
          <li>
            <a class="inline-block w-full h-full py-2 hover:underline cursor-pointer" href="/dev-blog/posts/Browser">Browser</a>
          </li>
        </ul>
      </nav>
    </div>
  </header>

          <main class="py-2 px-4 pt-10 max-w-3xl m-auto pb-20">
          
            <aside class="mt-14">
              <a href="/dev-blog/" class="hover:underline">Home</a> &gt; <a href="/dev-blog/posts/JavaScript" class="hover:underline">JavaScript</a> &gt; <a href="/dev-blog/posts/JavaScript/well-known-symbols" class="hover:underline">Well-Known symbols (번역)</a>
            </aside>
          
            
    <h1 id="well-known" class="text-2xl my-8 font-bold">
      well-known 심볼
    </h1><blockquote class="border-l-2 border-black pl-2 my-4"><p class="my-1 text-sm leading-7 mb-6">원문: <a href="https://h3manth.com/posts/Well-known-symbols/" class="text-orange-500">https://h3manth.com/posts/Well-known-symbols/</a></p></blockquote><p class="my-1 text-sm leading-7 mb-6">최근 공개 포럼에서 찾아보지 않고 well-known 심볼을 세 개 이상 말할 수 있는 사람이 있는지 물었는데, 아는 사람이 거의 없어서 이 포스팅을 작성하게 되었습니다.</p><p class="my-1 text-sm leading-7 mb-6">well-known 심볼은 모든 영역에서 동일하게 사용되는 등록되지 않은 심볼입니다. well-known symbol을 나열하면 다음과 같습니다.</p><ul class="my-2 px-3"><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">Symbol.iterator</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">Symbol.toStringTag</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">Symbol.toPrimitive</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">Symbol.asyncIterator</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">Symbol.hasInstance</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">Symbol.isConcatSpreadable</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">Symbol.species</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">Symbol.match</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">Symbol.matchall</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">Symbol.replace</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">Symbol.search</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">Symbol.split</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">Symbol.unscopables</p></li><li  class="text-base *:mb-0 *:mt-0 *:leading-6"><p class="my-1 text-sm leading-7 mb-6">Symbol.dispose</p></li></ul><p class="my-1 text-sm leading-7 mb-6">이 심볼 값들이 정말 유용한지 알기 위해 몇 가지 예를 살펴보겠습니다.</p><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Symbol.iterator</code>: 이 심볼은 객체의 기본 반복자를 정의하는 데 사용됩니다.
for-of 루프 또는 스프레드 연산자를 사용하여 객체에 대한 반복을 활성화하는 데 사용됩니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> };

obj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] = <span class="hljs-keyword">function</span>* () {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>)) {
    <span class="hljs-keyword">yield</span> [key, <span class="hljs-variable language_">this</span>[key]];
  }
};

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> obj) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${key}</span>: <span class="hljs-subst">${value}</span>`</span>);
}</code></pre><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Symbol.toStringTag</code>: 이 심볼은 객체에서 호출될 때 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Object.prototype.toString</code> 메서드가 반환하는 문자열 값을 지정하는 데 사용됩니다.
객체에 대한 사용자 지정 문자열 표현을 제공하는 데 사용할 수 있습니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  <span class="hljs-keyword">static</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>] = <span class="hljs-string">&quot;MyClass&quot;</span>;
}

<span class="hljs-keyword">const</span> myInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myInstance.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 결과 &#x27;[object MyClass]&#x27;</span></code></pre><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Symbol.toPrimitive</code>: 이 심볼은 암묵적으로 호출되는 객체의 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">valueOf</code> 및 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">toString</code> 메서드의 동작을 지정하는 데 사용됩니다.
객체에 대한 사용자 지정 문자열 및 숫자 표현을 제공하는 데 사용할 수 있습니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Life</span> {
  <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
  }

  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toPrimitive</span>](hint) {
    <span class="hljs-keyword">switch</span> (hint) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;number&quot;</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">valueOf</span>();
      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;string&quot;</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Forty Two&quot;</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;default&quot;</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  }
}

<span class="hljs-keyword">const</span> myLife = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Life</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+myLife); <span class="hljs-comment">// 42</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${myLife}</span>`</span>); <span class="hljs-comment">// &quot;Forty Two&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myLife + <span class="hljs-number">0</span>); <span class="hljs-comment">// 42</span></code></pre><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Symbol.asyncIterator</code>: 이 심볼은 객체에 대한 비동기 반복자를 정의하는 데 사용됩니다.
객체에 대한 비동기 반복을 활성화하는 데 사용됩니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAsyncIterable</span> {
  <span class="hljs-keyword">async</span> *[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">asyncIterator</span>]() {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
      <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>));
      <span class="hljs-keyword">yield</span> i;
    }
  }
}

(<span class="hljs-title function_">async</span> () =&gt; {
  <span class="hljs-keyword">for</span> <span class="hljs-title function_">await</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAsyncIterable</span>()) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);
  }
})();

<span class="hljs-comment">// 1초 후 결과:</span>
<span class="hljs-comment">// 0</span>
<span class="hljs-comment">// 2초 후 결과:</span>
<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 3초 후 결과:</span>
<span class="hljs-comment">// 2</span>
<span class="hljs-comment">// 4초 후 결과:</span>
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 5초 후 결과:</span>
<span class="hljs-comment">// 4</span></code></pre><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Symbol.hasInstance</code>: 이 심볼은 객체가 생성자의 인스턴스인지 확인하는 데 사용됩니다.
<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">instanceof</code> 연산자의 동작을 변경하는 데 사용할 수 있습니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> {
  <span class="hljs-keyword">static</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>](instance) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(instance);
  }
}

<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyArray</span>); <span class="hljs-comment">// true</span></code></pre><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Symbol.isConcatSpreadable</code>: 이 심볼은 다른 객체와 연결될 때 객체를 평탄하게 해야 하는지를 결정하는 데 사용됩니다.
<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Array.prototype.concat</code> 메서드의 동작을 변경하는 데 사용할 수 있습니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> spreadable = {
  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">isConcatSpreadable</span>]: <span class="hljs-literal">true</span>,
  <span class="hljs-number">0</span>: <span class="hljs-number">4</span>,
  <span class="hljs-number">1</span>: <span class="hljs-number">5</span>,
  <span class="hljs-number">2</span>: <span class="hljs-number">6</span>,
  <span class="hljs-attr">length</span>: <span class="hljs-number">3</span>,
};

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([].<span class="hljs-title function_">concat</span>(arr1, spreadable)); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span></code></pre><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Symbol.species</code>: 이 심볼은 파생 객체를 생성할 때 생성자를 지정하는 데 사용됩니다.
새 객체를 생성하는 내장 메서드 동작을 커스터 마이징 하는데 사용할 수 있습니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> {
  <span class="hljs-keyword">static</span> get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">species</span>]() {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>;
  }
}

<span class="hljs-keyword">const</span> myArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArray</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-keyword">const</span> mappedArray = myArray.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x * <span class="hljs-number">2</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mappedArray <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyArray</span>); <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mappedArray <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span></code></pre><p class="my-1 text-sm leading-7 mb-6">추신: 이 기능은 <a href="https://github.com/tc39/proposal-rm-builtin-subclassing" class="text-orange-500">향후</a> 삭제될 수 있습니다.</p><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">String.match</code>: 이 심볼은 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">String.prototype.match</code> 메서드를 사용할 때 검색할 값을 결정하는 데 사용됩니다.
이 메서드는 유사 RegExp 객체에 대한 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">match</code> 메서드 동작을 변경하는 데 사용할 수 있습니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> myRegex = <span class="hljs-regexp">/test/</span>;
<span class="hljs-string">&quot;/test/&quot;</span>.<span class="hljs-title function_">startsWith</span>(myRegex); <span class="hljs-comment">// TypeError 발생</span>

<span class="hljs-keyword">const</span> re = <span class="hljs-regexp">/foo/</span>;
re[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">match</span>] = <span class="hljs-literal">false</span>;
<span class="hljs-string">&quot;/foo/&quot;</span>.<span class="hljs-title function_">startsWith</span>(re); <span class="hljs-comment">// true</span>
<span class="hljs-string">&quot;/bar/&quot;</span>.<span class="hljs-title function_">endsWith</span>(re); <span class="hljs-comment">// false</span></code></pre><p class="my-1 text-sm leading-7 mb-6">추신: 이 심볼의 존재는 객체를 &quot;정규식이 되도록&quot; 표시합니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> myRegex = <span class="hljs-regexp">/foo/g</span>;
<span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;How many foos in the the foo foo bar?&quot;</span>;

<span class="hljs-keyword">for</span> (result <span class="hljs-keyword">of</span> myRegex[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">matchAll</span>](str)) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 일치하는 값들을 받습니다.</span>
}</code></pre><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Symbol.replace</code>: 이 심볼은 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">String.prototype.replace</code> 메서드를 사용할 때 대체 값을 결정하는 데 사용됩니다.
유사 RegExp 객체에 대한 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">replace</code> 메서드의 동작을 변경하는 데 사용할 수 있습니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">customReplace</span> = (<span class="hljs-params">str</span>) =&gt; str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\d+/g</span>, <span class="hljs-function">(<span class="hljs-params">match</span>) =&gt;</span> <span class="hljs-string">`-<span class="hljs-subst">${match}</span>-`</span>);

<span class="hljs-keyword">const</span> customString = {
  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">replace</span>]: customReplace,
};

<span class="hljs-keyword">const</span> originalString = <span class="hljs-string">&quot;foo123bar456baz&quot;</span>;

<span class="hljs-keyword">const</span> result = originalString.<span class="hljs-title function_">replace</span>(customString, <span class="hljs-string">&quot;*&quot;</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 결과 &quot;foo-123-bar-456-baz&quot;</span></code></pre><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Symbol.search</code>: 이 심볼은 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">String.prototype.search</code> 메서드를 사용할 때 검색할 값을 결정하는 데 사용됩니다.
유사 RegExp 객체에 대한 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">search</code> 메서드의 동작을 변경하는 데 사용할 수 있습니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">customSearch</span> = (<span class="hljs-params">str</span>) =&gt; str.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/\d+/</span>);

<span class="hljs-keyword">const</span> customRegExp = {
  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">search</span>]: customSearch,
};

<span class="hljs-keyword">const</span> string = <span class="hljs-string">&quot;foo123bar456baz&quot;</span>;

string.<span class="hljs-title function_">search</span>(customRegExp); <span class="hljs-comment">// 결과 3</span></code></pre><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Symbol.split</code>: 이 심볼은 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">String.prototype.split</code> 메서드를 사용할 때 분할할 값을 결정하는 데 사용됩니다.
유사 RegExp 객체에 대한 <code class="bg-gray-100 px-1 rounded-md inline-block text-sm">split</code> 메서드의 동작을 변경하는 데 사용할 수 있습니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Symbol</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;es6-symbol&quot;</span>);

<span class="hljs-keyword">const</span> <span class="hljs-title function_">customSplit</span> = (<span class="hljs-params">str</span>) =&gt; str.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/\d+/</span>);

<span class="hljs-keyword">const</span> customRegExp = {
  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">split</span>]: customSplit,
};

<span class="hljs-keyword">const</span> string = <span class="hljs-string">&quot;foo123bar456baz&quot;</span>;

string.<span class="hljs-title function_">split</span>(customRegExp); <span class="hljs-comment">// 결과 [ &#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27; ]</span></code></pre><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Symbol.unscopables</code>: 이 심볼은 with 문의 스코프에서 제외해야 하는 객체의 프로퍼티를 결정하는 데 사용됩니다.
with 문의 동작을 변경하는 데 사용할 수 있습니다.</p><pre><code class="my-4 hljs text-xs language-js"><span class="hljs-keyword">const</span> person = {
  <span class="hljs-attr">age</span>: <span class="hljs-number">42</span>,
};

person[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">unscopables</span>] = {
  <span class="hljs-attr">age</span>: <span class="hljs-literal">true</span>,
};

<span class="hljs-title function_">with</span> (person) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age);
  <span class="hljs-comment">// 예상되는 결과: Error: age is not defined</span>
}</code></pre><p class="my-1 text-sm leading-7 mb-6"><code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Symbol.dispose</code>: 명시적 리소스 관리는 명령적 방법(<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">Symbol.dispose</code>와 같은) 또는 선언적 방법 (<code class="bg-gray-100 px-1 rounded-md inline-block text-sm">using</code> 과 같은 블록스코프 선언)을 사용하여 사용자가 &quot;리소스&quot;의 수명을 명시적으로 관리하는 시스템을 말합니다.</p><pre><code class="my-4 hljs text-xs language-js">{
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">using</span> {
    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">dispose</span>]() {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);
     }
  };
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);
}
<span class="hljs-comment">// 1, 3, 2 이 로깅 됩니다.</span></code></pre><p class="my-1 text-sm leading-7 mb-6">이 글은 자바스크립트 언어에 내재된 잘 알려진 심볼에 대해 더 깊이 이해할 수 있도록 돕기 위해 작성되었습니다.
Symbol.iterator, Symbol.toStringTag, Symbol.for와 같은 심볼은 코드의 동작을 보강하고 조절하는 데 활용할 수 있는 정교하고 다재다능한 도구입니다.
자바스크립트 환경에서 사용 가능한 심볼을 넓게 이해하는 것은 고성능, 유지 관리 및 확장 가능한 응용프로그램을 개발하는 데 중요합니다.
따라서 프로젝트의 개념화 및 구현 단계에서 심볼들을 도입할 수 있는지를 판단해서 코드를 간소화하고 더 정교하고 우아한 방식으로 원하는 결과를 얻을 수 있도록 하는 것이 좋습니다.</p>
          </main>
        </div>
        <script src="/dev-blog/scripts/header.js"></script>
      </body>
    </html>
    